{"meta":{"title":"Marc Jin","subtitle":null,"description":"Stay tuned","author":"Marc Jin","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-05-23T03:31:59.000Z","updated":"2019-05-23T03:31:59.198Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-05-23T02:53:36.000Z","updated":"2019-05-23T02:54:09.897Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-23T02:53:46.000Z","updated":"2019-05-23T02:54:26.451Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"以「通」为语干的日语动词辨析","slug":"05通和逃的辨析","date":"2021-03-30T08:06:12.711Z","updated":"2021-03-31T04:13:40.442Z","comments":true,"path":"2021/03/30/05通和逃的辨析/","link":"","permalink":"http://yoursite.com/2021/03/30/05通和逃的辨析/","excerpt":"本文总结了相同语干的动词的不同训读和用法区别。","text":"本文总结了相同语干的动词的不同训读和用法区别。 通以通为词干的日语常用动词有以下四个： 通う かよう 通る とおる 通じる つうじる 通す とおす 首先通う表示定期的往返，也有自由来去，到处走来走去的意思，此时意思有点像「流れる」。也可以表示连通、此时意思和通じる一致。 学校に通う/会社に通う （定期往返） 血が体に通う （自由来去） 江戸へ通う街道 （连接性） 通じる即是自动词，也是他动词，主要表示的是连通性，此时强调到达目的地是有可能的，能达到的。古语写成通ずる。 電話が通じる 都市へ通じる道 内部の事情に通じる 通る和通す的意思几乎一致，区别在于通る为自动词，而通す为他动词。他们都是通过，经过的意思。 たくさんの人がぞろぞろ透る 銅線に電流を通す 由于他们两者还能写成透る和透す，所以还能表示光线等透过。","categories":[{"name":"语言","slug":"语言","permalink":"http://yoursite.com/categories/语言/"}],"tags":[{"name":"日语","slug":"日语","permalink":"http://yoursite.com/tags/日语/"},{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"}]},{"title":"否定助动词「ず」与「ぬ」的用法解说","slug":"04_zu_to_nu","date":"2021-03-15T09:05:00.000Z","updated":"2021-04-02T06:41:35.427Z","comments":true,"path":"2021/03/15/04_zu_to_nu/","link":"","permalink":"http://yoursite.com/2021/03/15/04_zu_to_nu/","excerpt":"本文总结了古日语和现代日语中否定助动词「ず」和「ぬ」的活用以及文法区别。","text":"本文总结了古日语和现代日语中否定助动词「ず」和「ぬ」的活用以及文法区别。 古日语中的否定助动词「ず」现代日本语中对一个动词进行否定一般为动词未然形加上否定助动词（打ち消しの助動詞）「ない」构成，比如 飲まない食べないしない 在古日语中，否定助动词「ず」与上文所提到的「ない」具有相同的作用，即加于动词未然形之后对某个动词进行否定。 飲まず食べずせず （せ是古日语中サ行活用的未然形） 与现代日语中「ないで」类似，古语中「ずに」作为连用修饰语表达“在～的状态下怎样怎样”，体会接下来两个句子： 何も言わずに去っていた （什么也不说，就走了）飲まず食わず働いてる （不吃不喝在工作） 接下来将要提到的是「ず」的活用。 连用形「ず」 家族に会えず、寂しいです。 终止形「ず」 あの奴は本当に恩知らず。 (那个家伙真的不知恩图报） 连体形「ぬ」这里就说到了比如容易混淆的一点：日语中ぬ是ず的连体形，也即ず是无法直接修饰体言的（名词，数词，代词），ぬ才可以。 触らぬ神に祟りなし。 （多一事不如少一事） 其他的一些ず的活用总结在下表，注意第二行的活用又被称为辅助活用，既可以单独使用也可以在其后加一些其他的助动词一起使用。123|未然形 | 连用形| 终止形| 连体形| 已然形 | 命令形||ず | ず| ず | ぬ| ね |ざり||ざら|ざり |ず | ざる|ざれ|ざり| 比如 選ばれざる国民 （不被选择的国民） 现代日语中否定助动词「ぬ」的延伸用法在现代日语中，ぬ除了用作否定助动词的连体形之外，还可以用作终止形。并且无论是连体形还是终止形的时候都可以与ん互换。例如， 知らぬ。分からん。","categories":[{"name":"语言","slug":"语言","permalink":"http://yoursite.com/categories/语言/"}],"tags":[{"name":"日语","slug":"日语","permalink":"http://yoursite.com/tags/日语/"},{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"},{"name":"古日语","slug":"古日语","permalink":"http://yoursite.com/tags/古日语/"}]},{"title":"OPERATING SYSTEM - PROCESS 进程","slug":"03-osprocess","date":"2019-01-12T06:04:18.000Z","updated":"2019-06-19T04:46:52.611Z","comments":true,"path":"2019/01/11/03-osprocess/","link":"","permalink":"http://yoursite.com/2019/01/11/03-osprocess/","excerpt":"最近节日大爆发，感恩节接着圣诞节，再接着元旦，除了跨年外实在是没有事情做，索性就学习好了。操作系统是一直以来想看的内容，自从大三的时候操作系统课拿了个D，就一直想什么时候重新学一下。好吧那就不要拖延的看起来吧。选择的课本是Abraham Silberschatz的经典之作“Operating System Concepts (10th Edition)”。本篇学习笔记出自于这本书的第三章“Process”。如果有什么地方理解不到位，或者写的不清楚欢迎留言指出，一起进步。","text":"最近节日大爆发，感恩节接着圣诞节，再接着元旦，除了跨年外实在是没有事情做，索性就学习好了。操作系统是一直以来想看的内容，自从大三的时候操作系统课拿了个D，就一直想什么时候重新学一下。好吧那就不要拖延的看起来吧。选择的课本是Abraham Silberschatz的经典之作“Operating System Concepts (10th Edition)”。本篇学习笔记出自于这本书的第三章“Process”。如果有什么地方理解不到位，或者写的不清楚欢迎留言指出，一起进步。 什么是Process？一个Process一般代表计算机的一项任务或一项活动，它并不是程序本身，而是程序加上程序现在处于的状态。一个process的memory可以分成以下几个section： Text表示一些固定长度的只读文本。 Data分为初始化的data和未初始化的data（bss），比如在C里的 $int$ $a = 3;$和$int$ $a;$。 Heap和stack都是flexible length的，如图所示heap是向高地址扩展的，而stack是向低地址扩展的。当你动态allocate一些memory的时候，其实获取的是heap的memory，在C里就是malloc函数族。 Stack的作用是存储一些临时变量，比如在调用一个函数的时候，输入，本地变量，还有返回地址会被push到stack上，直到函数调用完成后这一个block才被pop出来。 当然heap和stack有可能会无止境增长直到重叠，在现在操作系统里一般都会有机制防止这种情况发生。在stack即将和heap重叠的时候可能会报stack overflow的错。在heap空间不够的时候malloc会直接返回NULL告诉你heap空间不够了。 这里的重点是，程序不是process。如果一个程序需要完成多项工作，它可以produce很多进程。 Process的状态 New Process刚被创建 Ready Process正在等待被分配运行（通常有一个scheduler来分配） Running Process正在被执行 Waiting 相当于暂停，进程等待某个事件的发生（可能是某种signal，或者是OS把运行权限交回给这个process） Terminated Process完成工作，等待OS回收一般，处理器有几个core，就能真正同时运行几个process。比如6-core的处理器能真正同时处理6个process。在每个process core里，还能够伪同步地处理多个process，这是因为OS的scheduler会不停的context switch，在多个process中切换，造成多个process同时运行的假象。 Process Control Block这是一个拥有process各种metadata的字节块。它包括： Process State Program Counter 这个进程下一步需要执行的指令所在的位置，他会根据process的运行动态更新。 CPU Register 与这个process相关的寄存器里的值 CPU Schedueling Info, Memory Management Info, Stats, I/O Info 与这个process相关的Scheduler, Memory manager, 运行状态和I/O状态的信息其实所有的内容还是为了当这个process重新运行的时候恢复到上次运行的状态而储存的。 Process调度为什么要做process的调度？因为process会因为各种原因运行很长的时间，比如需要计算很多东西（Computing Bound），或者需要做很多I/O工作（I/O Bound），或者在等子进程完成他们的任务。为了不浪费CPU的资源，processer需要在多个process之间进行切换，防止有空闲的时间。 一般来说，OS会维持两个queue。其中一个是ready queue，是一些运行的时候被interrupt的process，他们随时随地都能被re-run。还有一个是wait queue，他们是本身在等待某些signal的process。当它们收到signal之后，会被放进ready queue。 CPU Scheduler的任务是在ready queue里选出一个process，并把他assign给某个core去运行。为了保证某些空闲的process不占用CPU，scheduler会很频繁的运行，即使会打断一些在正常运行的process。打断进程和恢复进程是通过context switch进行的，简单来说就是先把当前process的所有状态存到它的PCB里去，然后再resume另一个进程的PCB。Context switch是一个很纯粹的overhead，他除了调度之外不做其他的事情，并且它的速度取决于硬件。 创建一个Process一个Process是由其他的Process创建出来的，这个被创建的Process叫做子进程，它是由它的parent process创建出来的。在计算机boot的时候，OS会创建它的第一个process——init（pid=1）。它是所有进程的父进程。所以计算机里所有process的关系就组成了一个tree。每一个process会有自己的一个唯一的pid（process id）。 当进程创建自己的子进程的时候，子进程可以从OS那里拿到自己份的资源，也可以是从自己的父进程那里分一部分的资源。（这是OS层面的一个实现决策。）像后者的话可以防止一个进程创建出太多的子进程而占用太多资源。 当子进程被创建之后，它会复制一份父进程的地址空间。这里指的是两个进程的memory layout以及里面的数据是完全一样的，只是因为他们是虚拟地址空间，他们会指向实体memory里的不同位置。一般来说当子进程被创建后，它可以做和父进程完全一样的任务，或者可以做自己的新的任务。而父进程的话可以等待子进程的完成然后再terminate自己，或者也可以继续做事。 fork()函数是用来创建子进程的函数，它很神奇，在于它有两个返回值。由于调用fork之后子进程已经被创建了，这个函数的返回值其实是被两个进程可见的，但是它在两个进程的返回值是不一样的。它在子进程里返回0，在父进程里返回子进程的pid。 int main() { pid_t pid; pid = fork(); if (pid &lt; 0) { fprintf(stderr, &quot;Fork Failed&quot;); return 1; } else if (pid == 0) { execlp(&quot;/bin/ls&quot;, &quot;ls&quot;, NULL); } else { wait(NULL); printf(&quot;Child Process Complete.&quot;); } return 0; } 先看一下上面这个例子，父进程调用fork之后，两个进程一起进入if判断。pid == 0的那个分支会被子进程执行，因为fork在子进程里返回值为0。这里子进程是直接执行了一个新的任务了。else的那个分支会被父进程执行，因为子进程的pid永远是一个正数，父进程的做法是挂停，并且等待子进程的完成（查看wait函数）。父进程会在子进程结束后收到signal，并且重新执行下去。再看一个例子： int main() { fork(); fork(); fork(); return 0; } 那么包含当前进程，现在一共有多少进程在run？ 答案是8个。 结束一个Process当一个Process结束它的任务时，它通过调用exit函数实现system call，从而达成资源的回收。一个Process也可以被另一个Process所terminate，出于安全的考虑，一般只有它的父进程有这样的权限。父进程强行terminate它的子进程一般可以是因为，子进程占用了太多的资源，子进程的任务不再需要被完成了，或者父进程自己即将被terminate了。一般来说，父进程需要等其子进程都被terminate了，自己才能terminate。 如果父进程在子进程完成之前被terminate了，我们称子进程为orphan process。这种情况下，通常由init进程来通过wait函数把他kill掉。还有一个概念叫做zombie process。由于子进程结束的时候，它假设它的父进程还在运行中，并且最终会检查且kill掉自己。为了使父进程能够知道自己的状态，它必须还将自己的metadata维持在process table中。这样一个不再工作的，却等待父进程来kill掉自己的进程叫做zombie process。 IPC - Interprocess Communication 进程间通信什么情况下需要IPC？比如需要同时（不出错的）访问某一块地址上的数据，比如需要一起完成某一项大任务。IPC能够允许两个进程之间交换数据，更具体地说，发送和接受消息。具体说来，IPC的实现主要有shared memory和message passing两种方法。 Shared memory主要通过建立一块两个进程的公共内存区域。这种方法会使IPC比较快速，但是增加了实现的难度。如果两个进程都同意他们即将共享某一个内存区域，他们就可以这么做，同时他们应该做好concurrency的管理工作。POXIS系统里提供了这种IPC方法的API。 Message passing主要指两个进程之间互相收发信息，这种方法一般比较好实现，也不需要做concurrency的管理，所以分布式系统比较会用这种方法。如果两个进程可以互相传送信息的话，逻辑层面上他们之间需要有一个link。关于这个link，设计的时候可以有以下的几种option： Direct or Indirect 在每个process想和别的process进行通信的时候，需要严格说明对方的名称，或者只有sender需要说明对方的名称。这种精确到名字的link一般不太好使用，一旦process的id被update了，这种方法的overhead会非常高。Indirect的link的话，有port做过度。这样的话IPC就不是直接进程对进程，而是两组进程对port。port可以是OS层面的，也可以是进程层面的。Synchronization or Asynchronization 是不是允许sender和receiver 被block？Buffering 是不是允许sender和receiver有一个queue来存储一系列的消息？还是只能够一条一条的发送和接收？Pipe是一种message passing的IPC方法。一个pipe有两端，每一端都是一个file descriptor，一端作为读口，一端作为写口。原始的pipe允许一个进程从其中一端写入，允许另一个进程从另外一端读取。一般来说，原始的pipe的使用场景在于父进程和子进程之间的IPC。首先，父进程创建一个新的pipe，然后调用fork函数创建子进程。这时父进程和子进程同时都有相同的pipe。之后分别关闭掉父进程和子进程中不用的一端，即可完成父进程和子进程之间的写入读取。当然pipe的设计可以有多种option，比如是不是只允许父子进程的通信，或者允许单方向还是双方向。","categories":[{"name":"Geek","slug":"Geek","permalink":"http://yoursite.com/categories/Geek/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://yoursite.com/tags/OS/"}]},{"title":"日语中表示命令的几种用法区分","slug":"02-japcmd","date":"2018-12-24T05:40:03.000Z","updated":"2019-05-23T04:48:57.277Z","comments":true,"path":"2018/12/23/02-japcmd/","link":"","permalink":"http://yoursite.com/2018/12/23/02-japcmd/","excerpt":"标日初级下册的第29课「電気を消せ」中主要讲授了日语中表示命令的几种用法，他们在意思上都大同小异，主要都表示“快去做某事！”，或者“不准做某事！”。初学的时候没怎么在意，直到做了同步练习才发现自己什么都没搞清。。这篇日志主要对这几种用法做一些总结与区分。","text":"标日初级下册的第29课「電気を消せ」中主要讲授了日语中表示命令的几种用法，他们在意思上都大同小异，主要都表示“快去做某事！”，或者“不准做某事！”。初学的时候没怎么在意，直到做了同步练习才发现自己什么都没搞清。。这篇日志主要对这几种用法做一些总结与区分。 直接使用动词的命令型命令型的活用规则不再赘述，命令型可以说是语气最强的命令形式，一般是有权力的一方对待没有权力的一方，或者是年长者对待年轻者身上。紧急情况下（比如要求对方注意安全）可以使用。此外，还可以在体育比赛中加油鼓劲或者是男性友人之间劝酒中使用。女性一般不使用这种形式。（以下所有的例子取自于标日同步练习） 主任：おーい！鈴木！ちょうと来い！ -鈴木：はい、何ですか。 -主任：これを片付けろ！ 使用「動詞＋な」表示禁止语气最强表示禁止，或者否定的用法，意思是不要做某事，禁止做某事。 ここでタバコを吸うな！ 使用「動詞連用形＋なさい」语气次强烈表示做某事的用法。可以用在老师对学生，父母对子女身上。常常也会在考试的题目说明中看到「答えなさい」的用法。 早く起きなさい。遅刻するわよ。 使用「動詞て形・動詞ない形＋で」语气最不强烈的祈使用法，男性女性都可以用，一般用在比较亲密的人身上。 静かにして。大きな声を出さないで。赤ちゃんが寝たから。","categories":[{"name":"FineArts","slug":"FineArts","permalink":"http://yoursite.com/categories/FineArts/"}],"tags":[{"name":"Japanese","slug":"Japanese","permalink":"http://yoursite.com/tags/Japanese/"}]},{"title":"CMU好课推荐：15-122 PRINCIPLES OF IMPERATIVE PROGRAMMING","slug":"01-cmu15122","date":"2018-10-05T04:30:10.000Z","updated":"2019-05-23T04:49:18.789Z","comments":true,"path":"2018/10/04/01-cmu15122/","link":"","permalink":"http://yoursite.com/2018/10/04/01-cmu15122/","excerpt":"安然无恙（其实头发很有恙）的度过了在匹兹堡的第一个学期，能在五门课中活下来证明还是有进步的，即使忙碌的、焦躁的，绝望的日夜占了学期的大多数。要说这学期最喜欢最新奇收获最大的课，我觉得应该是当仁不让的15-122。","text":"安然无恙（其实头发很有恙）的度过了在匹兹堡的第一个学期，能在五门课中活下来证明还是有进步的，即使忙碌的、焦躁的，绝望的日夜占了学期的大多数。要说这学期最喜欢最新奇收获最大的课，我觉得应该是当仁不让的15-122。 迫于淫威，选择了这门不计入毕业学分的本科生level的CS课，全名叫做Principles of Imperative Programming，以教授命令式编程（C）与基本的数据结构为主线，是要declare CS major的学生必修的基础课以及核心课程。所以有200+的学生和30+的TA，并且基本上所有的学生都是first year（first year graduate的我惭愧的低下了头）。 这门课的workload要比我这学期上的所有其他研究生课程的workload都来的大。每周一交一个written homework（共13次），每周四交一个programming homework（共11次），每周两次lecture，课上会有随机的quiz（计入总分），每周一次lab（计入总分），每周一次recitation，两次midterm和一次final。 这门课讲了什么呢？首先从最最基础的二进制讲起，然后开始将数据结构与零零散散的东西穿插起来介绍（看到syllabus可以感觉到每节lecture的内容都是精心安排的）。数据结构有介绍了array，stack，queue，linked list，unbounded array，hash tables，set，BST，AVL tree，priority queue，heap，graph，union find等。 但是这门课不光只是介绍了数据结构，还有很多零零碎碎的东西也被提上了桌面。比如说lecture里有教几种sort和search的方法，命令式编程中的pointer和function pointer，编程时需要尊重client和library的interface，如何写各种test case，使用void*和函数指针写出generic的函数，C的内存模型，undefined behavior，虚拟机等。lab里有着重锻炼书写test case，recitation里还有对lecture内容的补充（比如说用stack实现DFS，课上用的是recursion）。 我为什么喜欢并推荐这门课呢？ 这门课有两位负责任的instructor。Stephanie虽然上课十句话里有一句讲错，写代码三行里必出错别字，但是上课非常有趣。在实现数据结构的interface的时候，她常常尝试用不同的方法，即使方向是完全错误的，她至少让我们看到了这么实现的弊端在哪里。作为一门CS的基础课，能够做到授之以渔便是最大的成功。Illiano作为这门课的主管，对整个课的质量把控的非常严格，所有的作业基本都是两天内出分，grading能够做到你心服口服。上课的方式也很有趣（貌似本科生的课都很有趣），比如说有一次编程作业是图片变换，有一个bonus的题，想出你最喜欢最美丽的图片变换并写代码。一周后的课堂上突如其来的评选出了top 10送小礼品+送加分。 这门课的TA非常负责（只能说有一些TA非常负责）。有一次written homework我做的比较差，因为有一道大题没太明白题目意思，于是就去OH准备和TA把分数argue回来，她非常耐心的和我解释每一条扣分点在哪里，把本来打算找他们算账的我说的心服口服。更加负责的是，后来我登录上去我的gradescope，发现她在我在OH问的那些问题的旁边把她的解释完整的加在了备注里，为的是我考试复习的时候比较方便。这是最最最让我感动的一点。还有，midterm2的时候，我因为时间来不及胡乱猜了两三个答案写在试卷上，有两个蒙对了但是TA没给我分。跑过去regrade，ta说一看你就是不会写瞎蒙的，不能给你分。 课程的设置非常的有foresight。学期初有一次编程作业里的一个task是对图片做高斯模糊，其中的一个步骤是对图片加padding，并且用方格遍历选取最大的元素。后来上到601 CNN的时候，才明白过来原来这就是CNN里的max pooling layer。其他的作业也非常实用，比如说用gap buffer实现text editor，写一个PRNG，使用heap实现huffman tree然后变成一个用来压缩文件的程序（真的可以用来压缩和解压缩文件和图片！），写一个虚拟机的decoder，类似于汇编码的decoder（真的可以用来跑c0文件的bytecode！）。 很难，很push。push是我对这门课最大的感受。比如说好死好活写了一次programming homework，只占总分里的2.5分，一次written homework只占100分的的1.2分。并且这门课是不curve的，严格按照90分以上是A的标准。真是对于任何一次作业都不敢不好好做（否则一次扣0.5分真的伤不起）。同时，总评的grading还会case by case，意思就是即使总评90+，如果三次考试的平均分不到80%，也会按照B处理。或者是如果programming homework的分数太低，就会收到D的总评，直接剥夺下学期选15-213的权利。这门课的push同时还体现在每次作业限制autolab的提交次数（5-7次），以及coding style的规范，以及有几次的作业需要考虑efficiency，以及有几次的作业是在due之后才会给你评分（意味着无法根据autolab的提示进行debug）。 整个课程的材料都让我感觉到设置的精心。比如说基本上每次的编程作业，都会提供几百个test case来测试你程序是否有bug。像最后一次作业，他写了350+个的test case来测试你的程序，我觉得这在一般的课程上是做不到的吧。另外，为了上这门课，这门课当初的设计者写了一门新的语言叫做C0。C0是C语言的一个子集，里面剥夺了一些容易让程序失控的特性，比如说casting，比如动态内存的回收，比如指针运算，比如一些ECF（break等）。同时添加了新的数据类型比如string，以及string的操作（以替代神烦的strxxx系列）。为了一门课程直接写一门新语言真的是细想极恐。 总而言之，15122真的是我到目前为止最满意的CS课（甚至超过15-513），强烈推荐闲的发慌的人去上一波。","categories":[{"name":"Geek","slug":"Geek","permalink":"http://yoursite.com/categories/Geek/"}],"tags":[{"name":"Course","slug":"Course","permalink":"http://yoursite.com/tags/Course/"}]}]}