<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Marc Jin</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-19T04:46:52.611Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Marc Jin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OPERATING SYSTEM - PROCESS 进程</title>
    <link href="http://yoursite.com/2019/01/11/03-osprocess/"/>
    <id>http://yoursite.com/2019/01/11/03-osprocess/</id>
    <published>2019-01-11T14:04:18.000Z</published>
    <updated>2019-06-19T04:46:52.611Z</updated>
    
    <content type="html"><![CDATA[<p>最近节日大爆发，感恩节接着圣诞节，再接着元旦，除了跨年外实在是没有事情做，索性就学习好了。操作系统是一直以来想看的内容，自从大三的时候操作系统课拿了个D，就一直想什么时候重新学一下。好吧那就不要拖延的看起来吧。选择的课本是Abraham Silberschatz的经典之作“Operating System Concepts (10th Edition)”。本篇学习笔记出自于这本书的第三章“Process”。如果有什么地方理解不到位，或者写的不清楚欢迎留言指出，一起进步。<br><a id="more"></a> </p><h3 id="什么是Process？"><a href="#什么是Process？" class="headerlink" title="什么是Process？"></a>什么是Process？</h3><p>一个Process一般代表计算机的一项任务或一项活动，它并不是程序本身，而是程序加上程序现在处于的状态。一个process的memory可以分成以下几个section：</p><ul><li>Text表示一些固定长度的只读文本。</li><li>Data分为初始化的data和未初始化的data（bss），比如在C里的 $int$ $a = 3;$和$int$ $a;$。</li><li>Heap和stack都是flexible length的，如图所示heap是向高地址扩展的，而stack是向低地址扩展的。当你动态allocate一些memory的时候，其实获取的是heap的memory，在C里就是malloc函数族。</li><li>Stack的作用是存储一些临时变量，比如在调用一个函数的时候，输入，本地变量，还有返回地址会被push到stack上，直到函数调用完成后这一个block才被pop出来。</li></ul><p>当然heap和stack有可能会无止境增长直到重叠，在现在操作系统里一般都会有机制防止这种情况发生。在stack即将和heap重叠的时候可能会报stack overflow的错。在heap空间不够的时候malloc会直接返回NULL告诉你heap空间不够了。</p><p>这里的重点是，程序不是process。如果一个程序需要完成多项工作，它可以produce很多进程。</p><h3 id="Process的状态"><a href="#Process的状态" class="headerlink" title="Process的状态"></a>Process的状态</h3><ul><li>New Process刚被创建</li><li>Ready Process正在等待被分配运行（通常有一个scheduler来分配）</li><li>Running Process正在被执行</li><li>Waiting 相当于暂停，进程等待某个事件的发生（可能是某种signal，或者是OS把运行权限交回给这个process）</li><li>Terminated Process完成工作，等待OS回收<br>一般，处理器有几个core，就能真正同时运行几个process。比如6-core的处理器能真正同时处理6个process。在每个process core里，还能够伪同步地处理多个process，这是因为OS的scheduler会不停的context switch，在多个process中切换，造成多个process同时运行的假象。</li></ul><h3 id="Process-Control-Block"><a href="#Process-Control-Block" class="headerlink" title="Process Control Block"></a>Process Control Block</h3><p>这是一个拥有process各种metadata的字节块。它包括：</p><ul><li>Process State</li><li>Program Counter 这个进程下一步需要执行的指令所在的位置，他会根据process的运行动态更新。</li><li>CPU Register 与这个process相关的寄存器里的值</li><li>CPU Schedueling Info, Memory Management Info, Stats, I/O Info 与这个process相关的Scheduler, Memory manager, 运行状态和I/O状态的信息<br>其实所有的内容还是为了当这个process重新运行的时候恢复到上次运行的状态而储存的。</li></ul><h3 id="Process调度"><a href="#Process调度" class="headerlink" title="Process调度"></a>Process调度</h3><p>为什么要做process的调度？因为process会因为各种原因运行很长的时间，比如需要计算很多东西（Computing Bound），或者需要做很多I/O工作（I/O Bound），或者在等子进程完成他们的任务。为了不浪费CPU的资源，processer需要在多个process之间进行切换，防止有空闲的时间。</p><p>一般来说，OS会维持两个queue。其中一个是ready queue，是一些运行的时候被interrupt的process，他们随时随地都能被re-run。还有一个是wait queue，他们是本身在等待某些signal的process。当它们收到signal之后，会被放进ready queue。</p><p>CPU Scheduler的任务是在ready queue里选出一个process，并把他assign给某个core去运行。为了保证某些空闲的process不占用CPU，scheduler会很频繁的运行，即使会打断一些在正常运行的process。打断进程和恢复进程是通过context switch进行的，简单来说就是先把当前process的所有状态存到它的PCB里去，然后再resume另一个进程的PCB。Context switch是一个很纯粹的overhead，他除了调度之外不做其他的事情，并且它的速度取决于硬件。</p><h3 id="创建一个Process"><a href="#创建一个Process" class="headerlink" title="创建一个Process"></a>创建一个Process</h3><p>一个Process是由其他的Process创建出来的，这个被创建的Process叫做子进程，它是由它的parent process创建出来的。在计算机boot的时候，OS会创建它的第一个process——init（pid=1）。它是所有进程的父进程。所以计算机里所有process的关系就组成了一个tree。每一个process会有自己的一个唯一的pid（process id）。</p><p>当进程创建自己的子进程的时候，子进程可以从OS那里拿到自己份的资源，也可以是从自己的父进程那里分一部分的资源。（这是OS层面的一个实现决策。）像后者的话可以防止一个进程创建出太多的子进程而占用太多资源。</p><p>当子进程被创建之后，它会复制一份父进程的地址空间。这里指的是两个进程的memory layout以及里面的数据是完全一样的，只是因为他们是虚拟地址空间，他们会指向实体memory里的不同位置。一般来说当子进程被创建后，它可以做和父进程完全一样的任务，或者可以做自己的新的任务。而父进程的话可以等待子进程的完成然后再terminate自己，或者也可以继续做事。</p><p>fork()函数是用来创建子进程的函数，它很神奇，在于它有两个返回值。由于调用fork之后子进程已经被创建了，这个函数的返回值其实是被两个进程可见的，但是它在两个进程的返回值是不一样的。它在子进程里返回0，在父进程里返回子进程的pid。</p><pre><code>int main() {      pid_t pid;    pid = fork();    if (pid &lt; 0) {        fprintf(stderr, &quot;Fork Failed&quot;);        return 1;    } else if (pid == 0) {        execlp(&quot;/bin/ls&quot;, &quot;ls&quot;, NULL);    } else {        wait(NULL);        printf(&quot;Child Process Complete.&quot;);    }    return 0;}</code></pre><p>先看一下上面这个例子，父进程调用fork之后，两个进程一起进入if判断。pid == 0的那个分支会被子进程执行，因为fork在子进程里返回值为0。这里子进程是直接执行了一个新的任务了。else的那个分支会被父进程执行，因为子进程的pid永远是一个正数，父进程的做法是挂停，并且等待子进程的完成（查看wait函数）。父进程会在子进程结束后收到signal，并且重新执行下去。再看一个例子：</p><pre><code>int main() {    fork();    fork();    fork();    return 0;}</code></pre><p>那么包含当前进程，现在一共有多少进程在run？ 答案是8个。</p><h3 id="结束一个Process"><a href="#结束一个Process" class="headerlink" title="结束一个Process"></a>结束一个Process</h3><p>当一个Process结束它的任务时，它通过调用exit函数实现system call，从而达成资源的回收。一个Process也可以被另一个Process所terminate，出于安全的考虑，一般只有它的父进程有这样的权限。父进程强行terminate它的子进程一般可以是因为，子进程占用了太多的资源，子进程的任务不再需要被完成了，或者父进程自己即将被terminate了。一般来说，父进程需要等其子进程都被terminate了，自己才能terminate。</p><p>如果父进程在子进程完成之前被terminate了，我们称子进程为orphan process。这种情况下，通常由init进程来通过wait函数把他kill掉。还有一个概念叫做zombie process。由于子进程结束的时候，它假设它的父进程还在运行中，并且最终会检查且kill掉自己。为了使父进程能够知道自己的状态，它必须还将自己的metadata维持在process table中。这样一个不再工作的，却等待父进程来kill掉自己的进程叫做zombie process。</p><h3 id="IPC-Interprocess-Communication-进程间通信"><a href="#IPC-Interprocess-Communication-进程间通信" class="headerlink" title="IPC - Interprocess Communication 进程间通信"></a>IPC - Interprocess Communication 进程间通信</h3><p>什么情况下需要IPC？比如需要同时（不出错的）访问某一块地址上的数据，比如需要一起完成某一项大任务。IPC能够允许两个进程之间交换数据，更具体地说，发送和接受消息。具体说来，IPC的实现主要有shared memory和message passing两种方法。</p><p>Shared memory主要通过建立一块两个进程的公共内存区域。这种方法会使IPC比较快速，但是增加了实现的难度。如果两个进程都同意他们即将共享某一个内存区域，他们就可以这么做，同时他们应该做好concurrency的管理工作。POXIS系统里提供了这种IPC方法的API。</p><p>Message passing主要指两个进程之间互相收发信息，这种方法一般比较好实现，也不需要做concurrency的管理，所以分布式系统比较会用这种方法。如果两个进程可以互相传送信息的话，逻辑层面上他们之间需要有一个link。关于这个link，设计的时候可以有以下的几种option：</p><p>Direct or Indirect 在每个process想和别的process进行通信的时候，需要严格说明对方的名称，或者只有sender需要说明对方的名称。这种精确到名字的link一般不太好使用，一旦process的id被update了，这种方法的overhead会非常高。Indirect的link的话，有port做过度。这样的话IPC就不是直接进程对进程，而是两组进程对port。port可以是OS层面的，也可以是进程层面的。<br>Synchronization or Asynchronization 是不是允许sender和receiver 被block？<br>Buffering 是不是允许sender和receiver有一个queue来存储一系列的消息？还是只能够一条一条的发送和接收？<br>Pipe是一种message passing的IPC方法。一个pipe有两端，每一端都是一个file descriptor，一端作为读口，一端作为写口。原始的pipe允许一个进程从其中一端写入，允许另一个进程从另外一端读取。一般来说，原始的pipe的使用场景在于父进程和子进程之间的IPC。首先，父进程创建一个新的pipe，然后调用fork函数创建子进程。这时父进程和子进程同时都有相同的pipe。之后分别关闭掉父进程和子进程中不用的一端，即可完成父进程和子进程之间的写入读取。当然pipe的设计可以有多种option，比如是不是只允许父子进程的通信，或者允许单方向还是双方向。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近节日大爆发，感恩节接着圣诞节，再接着元旦，除了跨年外实在是没有事情做，索性就学习好了。操作系统是一直以来想看的内容，自从大三的时候操作系统课拿了个D，就一直想什么时候重新学一下。好吧那就不要拖延的看起来吧。选择的课本是Abraham Silberschatz的经典之作“Operating System Concepts (10th Edition)”。本篇学习笔记出自于这本书的第三章“Process”。如果有什么地方理解不到位，或者写的不清楚欢迎留言指出，一起进步。&lt;br&gt;
    
    </summary>
    
      <category term="Geek" scheme="http://yoursite.com/categories/Geek/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>日语中表示命令的几种用法区分</title>
    <link href="http://yoursite.com/2018/12/23/02-japcmd/"/>
    <id>http://yoursite.com/2018/12/23/02-japcmd/</id>
    <published>2018-12-23T13:40:03.000Z</published>
    <updated>2019-05-23T04:48:57.277Z</updated>
    
    <content type="html"><![CDATA[<p>标日初级下册的第29课「電気を消せ」中主要讲授了日语中表示命令的几种用法，他们在意思上都大同小异，主要都表示“快去做某事！”，或者“不准做某事！”。初学的时候没怎么在意，直到做了同步练习才发现自己什么都没搞清。。这篇日志主要对这几种用法做一些总结与区分。<br><a id="more"></a> </p><h4 id="直接使用动词的命令型"><a href="#直接使用动词的命令型" class="headerlink" title="直接使用动词的命令型"></a>直接使用动词的命令型</h4><p>命令型的活用规则不再赘述，命令型可以说是语气最强的命令形式，一般是有权力的一方对待没有权力的一方，或者是年长者对待年轻者身上。紧急情况下（比如要求对方注意安全）可以使用。此外，还可以在体育比赛中加油鼓劲或者是男性友人之间劝酒中使用。女性一般不使用这种形式。（以下所有的例子取自于标日同步练习）</p><ul><li>主任：おーい！鈴木！ちょうと来い！　-鈴木：はい、何ですか。　-主任：これを片付けろ！</li></ul><h4 id="使用「動詞＋な」表示禁止"><a href="#使用「動詞＋な」表示禁止" class="headerlink" title="使用「動詞＋な」表示禁止"></a>使用「動詞＋な」表示禁止</h4><p>语气最强表示禁止，或者否定的用法，意思是不要做某事，禁止做某事。</p><p>ここでタバコを吸うな！</p><h4 id="使用「動詞連用形＋なさい」"><a href="#使用「動詞連用形＋なさい」" class="headerlink" title="使用「動詞連用形＋なさい」"></a>使用「動詞連用形＋なさい」</h4><p>语气次强烈表示做某事的用法。可以用在老师对学生，父母对子女身上。常常也会在考试的题目说明中看到「答えなさい」的用法。</p><p>早く起きなさい。遅刻するわよ。</p><h4 id="使用「動詞て形・動詞ない形＋で」"><a href="#使用「動詞て形・動詞ない形＋で」" class="headerlink" title="使用「動詞て形・動詞ない形＋で」"></a>使用「動詞て形・動詞ない形＋で」</h4><p>语气最不强烈的祈使用法，男性女性都可以用，一般用在比较亲密的人身上。</p><p>静かにして。大きな声を出さないで。赤ちゃんが寝たから。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标日初级下册的第29课「電気を消せ」中主要讲授了日语中表示命令的几种用法，他们在意思上都大同小异，主要都表示“快去做某事！”，或者“不准做某事！”。初学的时候没怎么在意，直到做了同步练习才发现自己什么都没搞清。。这篇日志主要对这几种用法做一些总结与区分。&lt;br&gt;
    
    </summary>
    
      <category term="FineArts" scheme="http://yoursite.com/categories/FineArts/"/>
    
    
      <category term="Japanese" scheme="http://yoursite.com/tags/Japanese/"/>
    
  </entry>
  
  <entry>
    <title>CMU好课推荐：15-122 PRINCIPLES OF IMPERATIVE PROGRAMMING</title>
    <link href="http://yoursite.com/2018/10/04/01-cmu15122/"/>
    <id>http://yoursite.com/2018/10/04/01-cmu15122/</id>
    <published>2018-10-04T13:30:10.000Z</published>
    <updated>2019-05-23T04:49:18.789Z</updated>
    
    <content type="html"><![CDATA[<p>安然无恙（其实头发很有恙）的度过了在匹兹堡的第一个学期，能在五门课中活下来证明还是有进步的，即使忙碌的、焦躁的，绝望的日夜占了学期的大多数。要说这学期最喜欢最新奇收获最大的课，我觉得应该是当仁不让的15-122。<br><a id="more"></a> </p><p>迫于淫威，选择了这门不计入毕业学分的本科生level的CS课，全名叫做Principles of Imperative Programming，以教授命令式编程（C）与基本的数据结构为主线，是要declare CS major的学生必修的基础课以及核心课程。所以有200+的学生和30+的TA，并且基本上所有的学生都是first year（first year graduate的我惭愧的低下了头）。</p><p>这门课的workload要比我这学期上的所有其他研究生课程的workload都来的大。每周一交一个written homework（共13次），每周四交一个programming homework（共11次），每周两次lecture，课上会有随机的quiz（计入总分），每周一次lab（计入总分），每周一次recitation，两次midterm和一次final。</p><p>这门课讲了什么呢？首先从最最基础的二进制讲起，然后开始将数据结构与零零散散的东西穿插起来介绍（看到syllabus可以感觉到每节lecture的内容都是精心安排的）。数据结构有介绍了array，stack，queue，linked list，unbounded array，hash tables，set，BST，AVL tree，priority queue，heap，graph，union find等。</p><p>但是这门课不光只是介绍了数据结构，还有很多零零碎碎的东西也被提上了桌面。比如说lecture里有教几种sort和search的方法，命令式编程中的pointer和function pointer，编程时需要尊重client和library的interface，如何写各种test case，使用void*和函数指针写出generic的函数，C的内存模型，undefined behavior，虚拟机等。lab里有着重锻炼书写test case，recitation里还有对lecture内容的补充（比如说用stack实现DFS，课上用的是recursion）。</p><p>我为什么喜欢并推荐这门课呢？</p><p>这门课有两位负责任的instructor。Stephanie虽然上课十句话里有一句讲错，写代码三行里必出错别字，但是上课非常有趣。在实现数据结构的interface的时候，她常常尝试用不同的方法，即使方向是完全错误的，她至少让我们看到了这么实现的弊端在哪里。作为一门CS的基础课，能够做到授之以渔便是最大的成功。Illiano作为这门课的主管，对整个课的质量把控的非常严格，所有的作业基本都是两天内出分，grading能够做到你心服口服。上课的方式也很有趣（貌似本科生的课都很有趣），比如说有一次编程作业是图片变换，有一个bonus的题，想出你最喜欢最美丽的图片变换并写代码。一周后的课堂上突如其来的评选出了top 10送小礼品+送加分。</p><p>这门课的TA非常负责（只能说有一些TA非常负责）。有一次written homework我做的比较差，因为有一道大题没太明白题目意思，于是就去OH准备和TA把分数argue回来，她非常耐心的和我解释每一条扣分点在哪里，把本来打算找他们算账的我说的心服口服。更加负责的是，后来我登录上去我的gradescope，发现她在我在OH问的那些问题的旁边把她的解释完整的加在了备注里，为的是我考试复习的时候比较方便。这是最最最让我感动的一点。还有，midterm2的时候，我因为时间来不及胡乱猜了两三个答案写在试卷上，有两个蒙对了但是TA没给我分。跑过去regrade，ta说一看你就是不会写瞎蒙的，不能给你分。</p><p>课程的设置非常的有foresight。学期初有一次编程作业里的一个task是对图片做高斯模糊，其中的一个步骤是对图片加padding，并且用方格遍历选取最大的元素。后来上到601 CNN的时候，才明白过来原来这就是CNN里的max pooling layer。其他的作业也非常实用，比如说用gap buffer实现text editor，写一个PRNG，使用heap实现huffman tree然后变成一个用来压缩文件的程序（真的可以用来压缩和解压缩文件和图片！），写一个虚拟机的decoder，类似于汇编码的decoder（真的可以用来跑c0文件的bytecode！）。</p><p>很难，很push。push是我对这门课最大的感受。比如说好死好活写了一次programming homework，只占总分里的2.5分，一次written homework只占100分的的1.2分。并且这门课是不curve的，严格按照90分以上是A的标准。真是对于任何一次作业都不敢不好好做（否则一次扣0.5分真的伤不起）。同时，总评的grading还会case by case，意思就是即使总评90+，如果三次考试的平均分不到80%，也会按照B处理。或者是如果programming homework的分数太低，就会收到D的总评，直接剥夺下学期选15-213的权利。这门课的push同时还体现在每次作业限制autolab的提交次数（5-7次），以及coding style的规范，以及有几次的作业需要考虑efficiency，以及有几次的作业是在due之后才会给你评分（意味着无法根据autolab的提示进行debug）。</p><p>整个课程的材料都让我感觉到设置的精心。比如说基本上每次的编程作业，都会提供几百个test case来测试你程序是否有bug。像最后一次作业，他写了350+个的test case来测试你的程序，我觉得这在一般的课程上是做不到的吧。另外，为了上这门课，这门课当初的设计者写了一门新的语言叫做C0。C0是C语言的一个子集，里面剥夺了一些容易让程序失控的特性，比如说casting，比如动态内存的回收，比如指针运算，比如一些ECF（break等）。同时添加了新的数据类型比如string，以及string的操作（以替代神烦的strxxx系列）。为了一门课程直接写一门新语言真的是细想极恐。</p><p>总而言之，15122真的是我到目前为止最满意的CS课（甚至超过15-513），强烈推荐闲的发慌的人去上一波。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安然无恙（其实头发很有恙）的度过了在匹兹堡的第一个学期，能在五门课中活下来证明还是有进步的，即使忙碌的、焦躁的，绝望的日夜占了学期的大多数。要说这学期最喜欢最新奇收获最大的课，我觉得应该是当仁不让的15-122。&lt;br&gt;
    
    </summary>
    
      <category term="Geek" scheme="http://yoursite.com/categories/Geek/"/>
    
    
      <category term="Course" scheme="http://yoursite.com/tags/Course/"/>
    
  </entry>
  
</feed>
