<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Marc Jin</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-05-06T00:52:15.281Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Marc Jin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>链表Linked List常用代码片段</title>
    <link href="http://yoursite.com/2021/05/05/08_linkedlist/"/>
    <id>http://yoursite.com/2021/05/05/08_linkedlist/</id>
    <published>2021-05-05T18:48:01.685Z</published>
    <updated>2021-05-06T00:52:15.281Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了面试中关于Linked List的一些常用代码片段。</p><a id="more"></a><p>关于单链表最基础的知识就不说了，链表中每一个Node都可以用以下的class表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class Node:</span><br><span class="line">self.__init__(self, val = <span class="number">-1</span>, next = <span class="literal">None</span>):</span><br><span class="line">self.val = val</span><br><span class="line">self.next = next</span><br></pre></td></tr></table></figure><p>在上算法课的时候可能还会更加完善的定义一个class单纯表示LinkedList，里面只有一个叫head的Node实例，但是在面试里为了简略没有这种必要。一般假设直接把链表头的Node作为一个input variable。</p><h1 id="Traverse-a-linked-list"><a href="#Traverse-a-linked-list" class="headerlink" title="Traverse a linked list"></a>Traverse a linked list</h1><p>链表的本质就是在上一个Node里存储下一个Node的地址，以便于我们可以遍历整个链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse_linked_list</span><span class="params">(head)</span>:</span></span><br><span class="line">curr = head  <span class="comment">#指针</span></span><br><span class="line">  <span class="keyword">while</span> curr:  <span class="comment">#当指针没有指到末尾</span></span><br><span class="line">    <span class="comment"># 访问当前Node</span></span><br><span class="line">    curr = curr.next  <span class="comment">#指针指向下一个Node</span></span><br></pre></td></tr></table></figure><p>如果最后需要复制一份当前的linked list，或者根据当前链表返回一个新的链表（比如说Leetcode#2），为了简便，我们常常先规定一个dummy node作为开头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_a_copied_list</span><span class="params">(head)</span>:</span></span><br><span class="line">  <span class="comment">#dummy是最后要返回的链表头，curr是旧链表当前的位置，curr_new是返回链表的尾部</span></span><br><span class="line">  curr = head</span><br><span class="line">  dummy = Node()</span><br><span class="line">  curr_new = dummy</span><br><span class="line">  <span class="keyword">while</span> curr:</span><br><span class="line">    curr_new.next = Node(curr.val)</span><br><span class="line">    curr_new = curr_new.next</span><br><span class="line">    curr = curr.next</span><br><span class="line">  <span class="keyword">return</span> dummy.next <span class="comment">#最后返回的时候需要删除最开始的dummy node</span></span><br></pre></td></tr></table></figure><p>你当然可以直接更新head成head.next，但我们就无法再追踪到输入链表的头部了。</p><h1 id="Reverse-a-linked-list"><a href="#Reverse-a-linked-list" class="headerlink" title="Reverse a linked list"></a>Reverse a linked list</h1><p>很多题目里需要把一个linked list倒过来，这种需求的话因为我们还是只能从头访问链表，如果需要in place变换的话， 只需要一前一后两个指针，后指针是还没有变换过的剩余链表的头，前指针是反链表的尾部，在当前轮次，我们需要将后指针的next指向反链表的尾部，再更新前后指针，举一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1-&gt;2-&gt;3-&gt;4</span></span><br><span class="line"><span class="comment"># None&lt;-1 2-&gt;3-&gt;4 (prev:1, curr = 2)</span></span><br><span class="line"><span class="comment"># None&lt;-1&lt;-2 3-&gt;4 (prev:2, curr = 3)</span></span><br><span class="line"><span class="comment"># None&lt;-1&lt;-2&lt;-3 4 (prev:3, curr = 4)</span></span><br><span class="line"><span class="comment"># None&lt;-1&lt;-2&lt;-3&lt;-4 (prev:4, curr = None) end</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_in_place</span><span class="params">(head)</span>:</span></span><br><span class="line">prev, curr = <span class="literal">None</span>, head</span><br><span class="line">  <span class="keyword">while</span> curr:</span><br><span class="line">    tmp = curr.next <span class="comment">#记录curr.next因为马上我们要把curr.next指向prev了</span></span><br><span class="line">    curr.next, prev, curr = prev, curr, tmp</span><br><span class="line">  <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><p>如果你需要边reverse边构建一个新的linkedlist，那么prev指针永远指向新链表的头，curr只起到一个遍历旧链表的作用，代码可以改成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(head)</span>:</span></span><br><span class="line">  prev, curr = <span class="literal">None</span>, head</span><br><span class="line">  <span class="keyword">while</span> curr:</span><br><span class="line">    tmp = Node(curr.val)</span><br><span class="line">    tmp.next, prev = prev, tmp</span><br><span class="line">    curr = curr.next</span><br><span class="line">  <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><h1 id="Slow-and-fast-pointers"><a href="#Slow-and-fast-pointers" class="headerlink" title="Slow and fast pointers"></a>Slow and fast pointers</h1><p>快慢指针指的是两个指针从相同的起点一起开始跑，快指针每次跑两格，慢指针每次跑一格。这样当快指针跑到链表末尾的时候，慢指针正好处于链表的中间点。这种方法常常用来将链表等分为两份。按照需求，也可以有第三个指针slow_prev每次都更新为slow的前面一个Node，然后在最后的时候设置其next为None，这样就可以把链表分为两个子链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_linked_list</span><span class="params">(head)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="comment">#链表长度为0或1时</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">  slow, fast, slow_prev = head, head, <span class="literal">None</span></span><br><span class="line">  <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">    fast, slow_prev, slow = fast.next.next, slow, slow.next</span><br><span class="line">  slow_prev.next = <span class="literal">None</span>  <span class="comment">#这里slow_prev不可能为None，故为安全的访问</span></span><br><span class="line">  <span class="keyword">return</span> [head, slow] <span class="comment">#return two sub linked list</span></span><br></pre></td></tr></table></figure><p>将快慢指针都初始化为head的话，slow指针最后要么指向最中间的元素（奇数个Node情况下），要么指向后部第一个元素（偶数个Node的情况下）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1,2,3,4,5,6</span></span><br><span class="line"><span class="comment"># slow,fast = 1,1 -&gt; 2,3 -&gt; 3,5 -&gt; 4,None   slow = 4</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1,2,3,4,5,6,7</span></span><br><span class="line"><span class="comment"># slow,fast = 1,1 -&gt; 2,3 -&gt; 3,5 -&gt; 4,7  slow = 4</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了面试中关于Linked List的一些常用代码片段。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>古日语文法（2）- 动词活用及接续</title>
    <link href="http://yoursite.com/2021/04/21/07/"/>
    <id>http://yoursite.com/2021/04/21/07/</id>
    <published>2021-04-21T07:41:52.683Z</published>
    <updated>2021-04-21T09:41:32.249Z</updated>
    
    <content type="html"><![CDATA[<p>动词活用很好玩很有意思就是了。</p><a id="more"></a><p>日语中的活用（かつよう）指的是对用言和助动词进行的词形变化，以适应于不同的语气及语义，也可以说成日语中的变位。用言指的是动词，形容词和形容动词。</p><p>这里提一句动词/形容词/形容动词均属于自立语。自立语指的是可以直接使用，具有实义的词汇种类。除了该三类外还有不能活用的名词，副词，连体词，接续词和感动词。与自立语相对立的则是附属语，附属语中能够活用的是助动词，不能活用的是助词。</p><p>这篇文章主要先介绍动词的活用。用现在的语法举个简单的例子，比如「読む」，它在接「ます」的时候会变成「読み」，接「ない」的时候会变成「読ま」，接「ば」的时候会变成「読め」。</p><p>如果大家使用市面上普遍的日语教材的话，动词活用应该会根据一类动词，二类动词和三类动词介绍他们不同的活用方式。日本的教育文法则是把动词分为五段活用，上一段活用，下一段活用，カ行活用和サ行活用，分别对应一类，二类，来る和以する为后缀的三类动词。</p><p>古日语中则将动词分为九类，其中四段活用，上一段活用，上二段活用，下一段活用和下二段活用统称为正格活用；而其余四类 - カ行変格活用、サ行変格活用、ラ行変格活用和ナ行変格活用则统称为变格活用。</p><h1 id="活用种类"><a href="#活用种类" class="headerlink" title="活用种类"></a>活用种类</h1><p>再介绍九类动词的活用之前，先来看看有哪些活用的种类。 正如上文用「読む」举的例子所言，不同的接续涉及到的活用是不同的。日语中共有六类活用。</p><h2 id="未然形"><a href="#未然形" class="headerlink" title="未然形"></a>未然形</h2><p>表示还没有发生，还未这样的语气。否定的时候会用到这种活用，古语中表示推量“好像”的时候会用到，表示被动，使役的时候也会用到。类似于现代日语里所谓的「ない」形。</p><h2 id="连用形"><a href="#连用形" class="headerlink" title="连用形"></a>连用形</h2><p>表示中顿，名词化，接其他用言，接一些助动词的时候。类似于现代日语里所谓的「ます」形，「て」形和「た」形。</p><h2 id="终止形"><a href="#终止形" class="headerlink" title="终止形"></a>终止形</h2><p>后面不接续任何东西，或者只接续终助词（语气助词）的时候使用。类似于现代日语里的动词现在肯定简体形。</p><h2 id="连体形"><a href="#连体形" class="headerlink" title="连体形"></a>连体形</h2><p>后接续体言，也即是名词的形式。现代日语里连体形和终止形已经几乎是统一了，你可以说「君に<strong>会う</strong>」，也可以用同样的形式说「君と<strong>会う</strong>場合」。但在古日语中他们常常是不一样的。</p><h2 id="已然形"><a href="#已然形" class="headerlink" title="已然形"></a>已然形</h2><p>也叫做假定形。现代日语里可以接「ば」表示假定条件，古日语里常用于表示原因和理由（假定条件不用此形式）。</p><h2 id="命令形"><a href="#命令形" class="headerlink" title="命令形"></a>命令形</h2><p>和终止形一样，后面不接任何东西，或者只接终助词，但用于表示命令的形式。</p><h1 id="正格活用"><a href="#正格活用" class="headerlink" title="正格活用"></a>正格活用</h1><h2 id="四段活用"><a href="#四段活用" class="headerlink" title="四段活用"></a>四段活用</h2><p>以「笑む」（えむ）举例。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>笑<strong>ま</strong></td><td>笑<strong>み</strong></td><td>笑<strong>む</strong></td><td>笑<strong>む</strong></td><td>笑<strong>め</strong></td><td>笑<strong>め</strong></td></tr></tbody></table></div><p>简单来记的话可以去掉词干把变形部分记成「ア・イ・ウ・ウ・エ・エ」。由于只涉及到a，i，u，e四段，故被称为四段活用。这类动词和现代日语里的一类动词大部分是重叠的。</p><h2 id="上一段活用"><a href="#上一段活用" class="headerlink" title="上一段活用"></a>上一段活用</h2><p>以「見る」举例。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>み</td><td>み</td><td>みる</td><td>みる</td><td>みれ</td><td>みよ</td></tr></tbody></table></div><p>简单记忆的话则是「イ・イ・イる・イる・イれ・イよ」。由于活用只涉及到i段（u段的上一段），故被称为上一段活用。这一类单词很好记，词尾る之前只有单个i段的音。常用的有：</p><ul><li>見る　みる</li><li>煮る　にる　</li><li>似る　にる</li><li>干る　ひる</li><li>着る　きる</li><li>射る　いる</li><li>鋳る　いる</li><li>居る　ゐる</li><li>率る　ゐる</li></ul><h2 id="下一段活用"><a href="#下一段活用" class="headerlink" title="下一段活用"></a>下一段活用</h2><p>常用的只有「蹴る」（ける）这一个单词。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>け</td><td>け</td><td>ける</td><td>ける</td><td>けれ</td><td>けよ</td></tr></tbody></table></div><p>简单记忆的话则是「ケ・ケ・ケる・ケる・ケれ・ケよ」。由于活用只涉及到e段（u段的下一段），故被称为下一段活用。</p><h2 id="上二段活用"><a href="#上二段活用" class="headerlink" title="上二段活用"></a>上二段活用</h2><p>以「過ぐ」举例。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>過ぎ</td><td>過ぎ</td><td>過ぐ</td><td>過ぐる</td><td>過ぐれ</td><td>過ぎよ</td></tr></tbody></table></div><p>记忆的时候则是可以简单记成「イ・イ・ウ・ウる・ウれ・イよ」。由于涉及到了i段和u段，故被称为上二段活用。</p><h2 id="下二段活用"><a href="#下二段活用" class="headerlink" title="下二段活用"></a>下二段活用</h2><p>以「受く」举例。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>受け</td><td>受け</td><td>受く</td><td>受くる</td><td>受くれ</td><td>受けよ</td></tr></tbody></table></div><p>记忆的时候则是可以简单记成「ケ・ケ・ウ・ウる・ウれ・ケよ」。由于涉及到了e段和u段，故被称为下二段活用。</p><h1 id="变格活用"><a href="#变格活用" class="headerlink" title="变格活用"></a>变格活用</h1><h2 id="カ行变格活用"><a href="#カ行变格活用" class="headerlink" title="カ行变格活用"></a>カ行变格活用</h2><p>一般指的是「来る」这个动词的活用。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>こ</td><td>き</td><td>く</td><td>くる</td><td>くれ</td><td>こ（よ）</td></tr></tbody></table></div><p>和现代日语的差别主要在于终止形只用く而不用くる，还有命令形也并不是こい而是こ或者こよ。</p><h2 id="サ行变格活用"><a href="#サ行变格活用" class="headerlink" title="サ行变格活用"></a>サ行变格活用</h2><p>典型的有「する」和「おはす」这两个动词。「おはす」为「いらっしゃる」的古语。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>せ</td><td>し</td><td>す</td><td>する</td><td>すれ</td><td>せよ</td></tr></tbody></table></div><h2 id="ナ行变格活用"><a href="#ナ行变格活用" class="headerlink" title="ナ行变格活用"></a>ナ行变格活用</h2><p>典型的有「死ぬ」和「往ぬ・去ぬ」。以「往ぬ」举例。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>往な</td><td>往に</td><td>往ぬ</td><td>往ぬる</td><td>往ぬれ</td><td>往ね</td></tr></tbody></table></div><h2 id="ラ行变格活用"><a href="#ラ行变格活用" class="headerlink" title="ラ行变格活用"></a>ラ行变格活用</h2><p>典型的有「あり」、「をり」、「はべり」、「いまそかり」等。以「あり」举例。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>あら</td><td>あり</td><td>あり</td><td>ある</td><td>あれ</td><td>あれ</td></tr></tbody></table></div><p>这个变格活用和四段活用的唯一差别是终止形和连用形同形而不是和连体形同形。</p><h1 id="特殊注意点"><a href="#特殊注意点" class="headerlink" title="特殊注意点"></a>特殊注意点</h1><h2 id="同一个动词古今分类不同"><a href="#同一个动词古今分类不同" class="headerlink" title="同一个动词古今分类不同"></a>同一个动词古今分类不同</h2><p>比如说「借りる」这个单词，现代日语中他是上一段活用，表否定的时候用未然形加上打消助动词「ない」或者「ず」，现代日语中应该是「借りない」。而古日语中，「借る」是一个四段活用动词，表否定的时候应该为「借らず」。</p><p>同样的还有「足る」「飽く」在古语中均为四段活用，而在现代日语中均为一段活用。「恨む」在古日语中为上二段活用，而在现代日语中为五段活用。</p><h2 id="容易与「ア行」搞混的变形部分"><a href="#容易与「ア行」搞混的变形部分" class="headerlink" title="容易与「ア行」搞混的变形部分"></a>容易与「ア行」搞混的变形部分</h2><p>「老ゆ」（おゆ）、「悔ゆ」（くゆ）、「報ゆ」（むくゆ）均为ヤ行上二段动词，虽然他们的未然形是以「い」结尾的，但他们不是「ア行」的活用。</p><p>「覚ゆ」（おぼゆ）、「燃ゆ」（もゆ）、「絶ゆ」（たゆ）、「見ゆ」（みゆ）均为ヤ行下二段动词，虽然他们的未然形是以「え」结尾的，但他们不是「ア行」的活用。</p><p>「植う」（うう）、「飢う」（うう）、「据う」（すう）均为ワ行下二段动词，虽然他们的终止形都是以「う」结尾的，但「植う」的未然形是「植ゑ」而不是「植え」。</p><h2 id="终止形只有一个假名的动词"><a href="#终止形只有一个假名的动词" class="headerlink" title="终止形只有一个假名的动词"></a>终止形只有一个假名的动词</h2><p>「得」（う）、「経」（ふ）、「寝」（ね）他们都是下二段动词。比如「得」，他的活用形则为「得（え）・得（え）・得（う）・得る（うる）・得れ（うれ）・得よ（えよ）」。</p><h2 id="具有两种活用的动词"><a href="#具有两种活用的动词" class="headerlink" title="具有两种活用的动词"></a>具有两种活用的动词</h2><p>「頼む」、「被く」（かづく）、「漬つ」（ひつ）都有四段和下二段两种活用方法，他们的区别是一个为他动词，一个为自动词。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动词活用很好玩很有意思就是了。&lt;/p&gt;
    
    </summary>
    
      <category term="语言" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="日语" scheme="http://yoursite.com/tags/%E6%97%A5%E8%AF%AD/"/>
    
      <category term="语法" scheme="http://yoursite.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>古日语文法（1）- 五十音图和古语假名遣</title>
    <link href="http://yoursite.com/2021/04/11/06/"/>
    <id>http://yoursite.com/2021/04/11/06/</id>
    <published>2021-04-11T07:09:26.185Z</published>
    <updated>2021-04-11T08:27:54.357Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习N3的道路上偶尔开始接触比较深奥/古早的语法，然后思绪就开始从原来的仅追求知其然变成了想知其所以然。又偶然看到了一些关于语源和文法分析的文章，所以打算入门一下古日语 —— 其中的一部分对理解现代日语是很有帮助的。</p><a id="more"></a><h1 id="五十音图"><a href="#五十音图" class="headerlink" title="五十音图"></a>五十音图</h1><p>在入门现代日语的时候，大部分人接触的第一道门槛就是记忆五十音图。说是五十音图，其实不如说是46音图。除了「ア行」、「カ行」、「サ行」、「タ行」、「ナ行」、「ハ行」、「マ行」、「ラ行」的八行是完整的之外，「ヤ行」只保留了「や・ゆ・よ」，「ワ行」只保留了「わ・を」，再另外加上一个拨音「ん」。</p><p>而在古语中，五十音图确确实实是五十个音。在其余八行仍为完整的情况下，「ヤ行」和「ワ行」也是完整的。</p><div class="table-container"><table><thead><tr><th></th><th>ア段</th><th>イ段</th><th>ウ段</th><th>エ段</th><th>オ段</th></tr></thead><tbody><tr><td>ヤ行</td><td>や　ya</td><td><strong>い</strong>　i</td><td>ゆ　yu</td><td><strong>え</strong>　e</td><td>よ　yo</td></tr><tr><td>ワ行</td><td>わ　wa</td><td><strong>ゐ</strong>　i</td><td><strong>う</strong>　u</td><td><strong>ゑ</strong>　e</td><td>を　wo</td></tr></tbody></table></div><h1 id="假名遣"><a href="#假名遣" class="headerlink" title="假名遣"></a>假名遣</h1><h2 id="「ハ行」的读音"><a href="#「ハ行」的读音" class="headerlink" title="「ハ行」的读音"></a>「ハ行」的读音</h2><p>古语中 「ハ行」的读音一般为「ワ行」，这也是为什么提示助词は（表主题）直到如今还在念wa的原因。</p><blockquote><p><strong>いはひ</strong>　→  祝い</p><p><strong>いへ</strong>　→  家</p><p><strong>いふ</strong>　→  言う</p></blockquote><p>但是当「ハ行」位于语头的时候，不变音。</p><blockquote><p><strong>はな</strong>　→  花</p></blockquote><h2 id="双重母音的连读"><a href="#双重母音的连读" class="headerlink" title="双重母音的连读"></a>双重母音的连读</h2><p>当有两个母音连在一起的时候，为了发音方便，会产生音变。具体为：</p><ul><li>あう　au →　おう ō</li><li>いう　iu →　ゆう yū</li><li>えう　eu →　よう yō</li><li>おう　ou →　おう ō</li></ul><blockquote><p><strong>あうむ</strong>　→　鸚鵡(おうむ）</p><p><strong>いうなり</strong>　→　優なり(ゆうなり）</p><p><strong>えうじ</strong>　→　用事(ようじ）</p><p><strong>おうな</strong>　→　嫗(おうな）</p></blockquote><h2 id="以直音表拗音"><a href="#以直音表拗音" class="headerlink" title="以直音表拗音"></a>以直音表拗音</h2><p>古语中有些情况下，假名的普通组合能音变成拗音。以两个例子来说明：</p><blockquote><p><strong>てふ</strong>　→　てう　t[eu] →  　t[yō] 　→　ちょう　蝶</p><p><strong>けふ</strong>　→　けう　k[eu] →  　k[yō] 　→　きょう　今日</p></blockquote><p>以上的例子结合了ha的wa音变和双重母音的连读。</p><h2 id="「ゐ、ゑ、を」的读音"><a href="#「ゐ、ゑ、を」的读音" class="headerlink" title="「ゐ、ゑ、を」的读音"></a>「ゐ、ゑ、を」的读音</h2><p>他们的读音即为i，e，o。</p><blockquote><p><strong>居る（ゐる）</strong>　→　いる</p><p><strong>声（こゑ）</strong>　→　こえ</p><p><strong>折（をり）</strong>　→　おり</p></blockquote><h2 id="「む」的读音"><a href="#「む」的读音" class="headerlink" title="「む」的读音"></a>「む」的读音</h2><p>在单词中间的「む」，助动词「む・らむ」，助词「なむ」中的「む」都读成拨音「ん」。</p><blockquote><p> <strong>東（ひむがし）</strong>　→　ひんがし</p><p><strong>行くらむ（いくらむ）</strong>　→　行くらん</p></blockquote><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>结合以上五个常用的古语假名遣，严格意义上无论古语中的词汇是怎么写的，都能念出他们的正确读音。以下左边是古语中一些词汇的假名标法，将他们翻译之后发现读法和现代相差无几。所以一般，无论古语里的假名注音写的多么fancy，读法还是会和现代日语很相似。</p><blockquote><p><strong>匂ひ（にほひ）</strong>　→　匂い（におい）</p><p><strong>田舎（ゐなか）</strong>　→　田舎（いなか）</p><p><strong>酔ふ（ゑふ）</strong>　→　酔う（よう）</p><p><strong>荻（をぎ）</strong>　→　荻（おぎ）</p><p><strong>扇（あふぎ）</strong>　→　扇（おうぎ）</p><p><strong>追ふ（おふ）</strong>　→　追う（おう）</p><p><strong>手水（てうづ）</strong>　→　手水（ちょうず）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习N3的道路上偶尔开始接触比较深奥/古早的语法，然后思绪就开始从原来的仅追求知其然变成了想知其所以然。又偶然看到了一些关于语源和文法分析的文章，所以打算入门一下古日语 —— 其中的一部分对理解现代日语是很有帮助的。&lt;/p&gt;
    
    </summary>
    
      <category term="语言" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="日语" scheme="http://yoursite.com/tags/%E6%97%A5%E8%AF%AD/"/>
    
      <category term="语法" scheme="http://yoursite.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>以「通」为语干的日语动词辨析</title>
    <link href="http://yoursite.com/2021/03/30/05%E9%80%9A%E5%92%8C%E9%80%83%E7%9A%84%E8%BE%A8%E6%9E%90/"/>
    <id>http://yoursite.com/2021/03/30/05通和逃的辨析/</id>
    <published>2021-03-30T08:06:12.711Z</published>
    <updated>2021-03-31T04:13:40.442Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结了相同语干的动词的不同训读和用法区别。<br><a id="more"></a></p><h3 id="通"><a href="#通" class="headerlink" title="通"></a>通</h3><p>以通为词干的日语常用动词有以下四个：</p><blockquote><p>　通う  　かよう</p><p>　通る  　とおる</p><p>　通じる  　つうじる</p><p>　通す  　とおす</p></blockquote><p>首先通う表示定期的往返，也有自由来去，到处走来走去的意思，此时意思有点像「流れる」。也可以表示连通、此时意思和通じる一致。</p><blockquote><p>　学校に通う/会社に通う   （定期往返）</p><p>　血が体に通う  （自由来去）</p><p>　江戸へ通う街道   （连接性）</p></blockquote><p>通じる即是自动词，也是他动词，主要表示的是连通性，此时强调到达目的地是有可能的，能达到的。古语写成通ずる。</p><blockquote><p>電話が通じる </p><p>都市へ通じる道</p><p>内部の事情に通じる</p></blockquote><p>通る和通す的意思几乎一致，区别在于通る为自动词，而通す为他动词。他们都是通过，经过的意思。</p><blockquote><p>たくさんの人がぞろぞろ透る</p><p>銅線に電流を通す</p></blockquote><p>由于他们两者还能写成透る和透す，所以还能表示光线等透过。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结了相同语干的动词的不同训读和用法区别。&lt;br&gt;
    
    </summary>
    
      <category term="语言" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="日语" scheme="http://yoursite.com/tags/%E6%97%A5%E8%AF%AD/"/>
    
      <category term="语法" scheme="http://yoursite.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>否定助动词「ず」与「ぬ」的用法解说</title>
    <link href="http://yoursite.com/2021/03/15/04_zu_to_nu/"/>
    <id>http://yoursite.com/2021/03/15/04_zu_to_nu/</id>
    <published>2021-03-15T09:05:00.000Z</published>
    <updated>2021-04-02T06:43:15.661Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结了古日语和现代日语中否定助动词「ず」和「ぬ」的活用以及文法区别。<br><a id="more"></a> </p><h3 id="古日语中的否定助动词「ず」"><a href="#古日语中的否定助动词「ず」" class="headerlink" title="古日语中的否定助动词「ず」"></a>古日语中的否定助动词「ず」</h3><p>现代日本语中对一个动词进行否定一般为动词未然形加上否定助动词（打ち消しの助動詞）「ない」构成，比如</p><blockquote><p><strong>飲まない</strong><br><strong>食べない</strong><br><strong>しない</strong></p></blockquote><p>在古日语中，否定助动词「ず」与上文所提到的「ない」具有相同的作用，即加于动词未然形之后对某个动词进行否定。</p><blockquote><p><strong>飲まず</strong><br><strong>食べず</strong><br><strong>せず</strong>  （せ是古日语中サ行活用的未然形）</p></blockquote><p>与现代日语中「ないで」类似，古语中「ずに」作为连用修饰语表达“在～的状态下怎样怎样”，体会接下来两个句子：</p><blockquote><p><strong>何も言わずに去っていた</strong> （什么也不说，就走了）<br><strong>飲まず食わず働いてる</strong> （不吃不喝在工作）</p></blockquote><p>接下来将要提到的是「ず」的活用。</p><h4 id="连用形「ず」"><a href="#连用形「ず」" class="headerlink" title="连用形「ず」"></a>连用形「ず」</h4><blockquote><p><strong>家族に会えず、寂しいです。</strong></p></blockquote><h4 id="终止形「ず」"><a href="#终止形「ず」" class="headerlink" title="终止形「ず」"></a>终止形「ず」</h4><blockquote><p><strong>あの奴は本当に恩知らず。</strong> (那个家伙真的不知恩图报）</p></blockquote><h4 id="连体形「ぬ」"><a href="#连体形「ぬ」" class="headerlink" title="连体形「ぬ」"></a>连体形「ぬ」</h4><p>这里就说到了比如容易混淆的一点：日语中ぬ是ず的连体形，也即ず是无法直接修饰体言的（名词，数词，代词），ぬ才可以。</p><blockquote><p><strong>触らぬ神に祟りなし。</strong> （多一事不如少一事）</p></blockquote><p>其他的一些ず的活用总结在下表，注意第二行的活用又被称为辅助活用，既可以单独使用也可以在其后加一些其他的助动词一起使用。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>ず</td><td>ず</td><td>ず　</td><td>ぬ</td><td>ね　</td><td>ざり</td></tr><tr><td>ざら</td><td>ざり　</td><td>ず　</td><td>ざる</td><td>ざれ</td><td>ざり</td></tr></tbody></table></div><p>比如</p><blockquote><p><strong>選ばれざる国民</strong>　（不被选择的国民）</p></blockquote><h3 id="现代日语中否定助动词「ぬ」的延伸用法"><a href="#现代日语中否定助动词「ぬ」的延伸用法" class="headerlink" title="现代日语中否定助动词「ぬ」的延伸用法"></a>现代日语中否定助动词「ぬ」的延伸用法</h3><p>在现代日语中，ぬ除了用作否定助动词的连体形之外，还可以用作终止形。并且无论是连体形还是终止形的时候都可以与ん互换。例如，</p><blockquote><p><strong> 知らぬ。</strong><br><strong>分からん。</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结了古日语和现代日语中否定助动词「ず」和「ぬ」的活用以及文法区别。&lt;br&gt;
    
    </summary>
    
      <category term="语言" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="日语" scheme="http://yoursite.com/tags/%E6%97%A5%E8%AF%AD/"/>
    
      <category term="语法" scheme="http://yoursite.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="古日语" scheme="http://yoursite.com/tags/%E5%8F%A4%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>OPERATING SYSTEM - PROCESS 进程</title>
    <link href="http://yoursite.com/2019/01/11/03-osprocess/"/>
    <id>http://yoursite.com/2019/01/11/03-osprocess/</id>
    <published>2019-01-12T06:04:18.000Z</published>
    <updated>2019-06-19T04:46:52.611Z</updated>
    
    <content type="html"><![CDATA[<p>最近节日大爆发，感恩节接着圣诞节，再接着元旦，除了跨年外实在是没有事情做，索性就学习好了。操作系统是一直以来想看的内容，自从大三的时候操作系统课拿了个D，就一直想什么时候重新学一下。好吧那就不要拖延的看起来吧。选择的课本是Abraham Silberschatz的经典之作“Operating System Concepts (10th Edition)”。本篇学习笔记出自于这本书的第三章“Process”。如果有什么地方理解不到位，或者写的不清楚欢迎留言指出，一起进步。<br><a id="more"></a> </p><h3 id="什么是Process？"><a href="#什么是Process？" class="headerlink" title="什么是Process？"></a>什么是Process？</h3><p>一个Process一般代表计算机的一项任务或一项活动，它并不是程序本身，而是程序加上程序现在处于的状态。一个process的memory可以分成以下几个section：</p><ul><li>Text表示一些固定长度的只读文本。</li><li>Data分为初始化的data和未初始化的data（bss），比如在C里的 $int$ $a = 3;$和$int$ $a;$。</li><li>Heap和stack都是flexible length的，如图所示heap是向高地址扩展的，而stack是向低地址扩展的。当你动态allocate一些memory的时候，其实获取的是heap的memory，在C里就是malloc函数族。</li><li>Stack的作用是存储一些临时变量，比如在调用一个函数的时候，输入，本地变量，还有返回地址会被push到stack上，直到函数调用完成后这一个block才被pop出来。</li></ul><p>当然heap和stack有可能会无止境增长直到重叠，在现在操作系统里一般都会有机制防止这种情况发生。在stack即将和heap重叠的时候可能会报stack overflow的错。在heap空间不够的时候malloc会直接返回NULL告诉你heap空间不够了。</p><p>这里的重点是，程序不是process。如果一个程序需要完成多项工作，它可以produce很多进程。</p><h3 id="Process的状态"><a href="#Process的状态" class="headerlink" title="Process的状态"></a>Process的状态</h3><ul><li>New Process刚被创建</li><li>Ready Process正在等待被分配运行（通常有一个scheduler来分配）</li><li>Running Process正在被执行</li><li>Waiting 相当于暂停，进程等待某个事件的发生（可能是某种signal，或者是OS把运行权限交回给这个process）</li><li>Terminated Process完成工作，等待OS回收<br>一般，处理器有几个core，就能真正同时运行几个process。比如6-core的处理器能真正同时处理6个process。在每个process core里，还能够伪同步地处理多个process，这是因为OS的scheduler会不停的context switch，在多个process中切换，造成多个process同时运行的假象。</li></ul><h3 id="Process-Control-Block"><a href="#Process-Control-Block" class="headerlink" title="Process Control Block"></a>Process Control Block</h3><p>这是一个拥有process各种metadata的字节块。它包括：</p><ul><li>Process State</li><li>Program Counter 这个进程下一步需要执行的指令所在的位置，他会根据process的运行动态更新。</li><li>CPU Register 与这个process相关的寄存器里的值</li><li>CPU Schedueling Info, Memory Management Info, Stats, I/O Info 与这个process相关的Scheduler, Memory manager, 运行状态和I/O状态的信息<br>其实所有的内容还是为了当这个process重新运行的时候恢复到上次运行的状态而储存的。</li></ul><h3 id="Process调度"><a href="#Process调度" class="headerlink" title="Process调度"></a>Process调度</h3><p>为什么要做process的调度？因为process会因为各种原因运行很长的时间，比如需要计算很多东西（Computing Bound），或者需要做很多I/O工作（I/O Bound），或者在等子进程完成他们的任务。为了不浪费CPU的资源，processer需要在多个process之间进行切换，防止有空闲的时间。</p><p>一般来说，OS会维持两个queue。其中一个是ready queue，是一些运行的时候被interrupt的process，他们随时随地都能被re-run。还有一个是wait queue，他们是本身在等待某些signal的process。当它们收到signal之后，会被放进ready queue。</p><p>CPU Scheduler的任务是在ready queue里选出一个process，并把他assign给某个core去运行。为了保证某些空闲的process不占用CPU，scheduler会很频繁的运行，即使会打断一些在正常运行的process。打断进程和恢复进程是通过context switch进行的，简单来说就是先把当前process的所有状态存到它的PCB里去，然后再resume另一个进程的PCB。Context switch是一个很纯粹的overhead，他除了调度之外不做其他的事情，并且它的速度取决于硬件。</p><h3 id="创建一个Process"><a href="#创建一个Process" class="headerlink" title="创建一个Process"></a>创建一个Process</h3><p>一个Process是由其他的Process创建出来的，这个被创建的Process叫做子进程，它是由它的parent process创建出来的。在计算机boot的时候，OS会创建它的第一个process——init（pid=1）。它是所有进程的父进程。所以计算机里所有process的关系就组成了一个tree。每一个process会有自己的一个唯一的pid（process id）。</p><p>当进程创建自己的子进程的时候，子进程可以从OS那里拿到自己份的资源，也可以是从自己的父进程那里分一部分的资源。（这是OS层面的一个实现决策。）像后者的话可以防止一个进程创建出太多的子进程而占用太多资源。</p><p>当子进程被创建之后，它会复制一份父进程的地址空间。这里指的是两个进程的memory layout以及里面的数据是完全一样的，只是因为他们是虚拟地址空间，他们会指向实体memory里的不同位置。一般来说当子进程被创建后，它可以做和父进程完全一样的任务，或者可以做自己的新的任务。而父进程的话可以等待子进程的完成然后再terminate自己，或者也可以继续做事。</p><p>fork()函数是用来创建子进程的函数，它很神奇，在于它有两个返回值。由于调用fork之后子进程已经被创建了，这个函数的返回值其实是被两个进程可见的，但是它在两个进程的返回值是不一样的。它在子进程里返回0，在父进程里返回子进程的pid。</p><pre><code>int main() {      pid_t pid;    pid = fork();    if (pid &lt; 0) {        fprintf(stderr, &quot;Fork Failed&quot;);        return 1;    } else if (pid == 0) {        execlp(&quot;/bin/ls&quot;, &quot;ls&quot;, NULL);    } else {        wait(NULL);        printf(&quot;Child Process Complete.&quot;);    }    return 0;}</code></pre><p>先看一下上面这个例子，父进程调用fork之后，两个进程一起进入if判断。pid == 0的那个分支会被子进程执行，因为fork在子进程里返回值为0。这里子进程是直接执行了一个新的任务了。else的那个分支会被父进程执行，因为子进程的pid永远是一个正数，父进程的做法是挂停，并且等待子进程的完成（查看wait函数）。父进程会在子进程结束后收到signal，并且重新执行下去。再看一个例子：</p><pre><code>int main() {    fork();    fork();    fork();    return 0;}</code></pre><p>那么包含当前进程，现在一共有多少进程在run？ 答案是8个。</p><h3 id="结束一个Process"><a href="#结束一个Process" class="headerlink" title="结束一个Process"></a>结束一个Process</h3><p>当一个Process结束它的任务时，它通过调用exit函数实现system call，从而达成资源的回收。一个Process也可以被另一个Process所terminate，出于安全的考虑，一般只有它的父进程有这样的权限。父进程强行terminate它的子进程一般可以是因为，子进程占用了太多的资源，子进程的任务不再需要被完成了，或者父进程自己即将被terminate了。一般来说，父进程需要等其子进程都被terminate了，自己才能terminate。</p><p>如果父进程在子进程完成之前被terminate了，我们称子进程为orphan process。这种情况下，通常由init进程来通过wait函数把他kill掉。还有一个概念叫做zombie process。由于子进程结束的时候，它假设它的父进程还在运行中，并且最终会检查且kill掉自己。为了使父进程能够知道自己的状态，它必须还将自己的metadata维持在process table中。这样一个不再工作的，却等待父进程来kill掉自己的进程叫做zombie process。</p><h3 id="IPC-Interprocess-Communication-进程间通信"><a href="#IPC-Interprocess-Communication-进程间通信" class="headerlink" title="IPC - Interprocess Communication 进程间通信"></a>IPC - Interprocess Communication 进程间通信</h3><p>什么情况下需要IPC？比如需要同时（不出错的）访问某一块地址上的数据，比如需要一起完成某一项大任务。IPC能够允许两个进程之间交换数据，更具体地说，发送和接受消息。具体说来，IPC的实现主要有shared memory和message passing两种方法。</p><p>Shared memory主要通过建立一块两个进程的公共内存区域。这种方法会使IPC比较快速，但是增加了实现的难度。如果两个进程都同意他们即将共享某一个内存区域，他们就可以这么做，同时他们应该做好concurrency的管理工作。POXIS系统里提供了这种IPC方法的API。</p><p>Message passing主要指两个进程之间互相收发信息，这种方法一般比较好实现，也不需要做concurrency的管理，所以分布式系统比较会用这种方法。如果两个进程可以互相传送信息的话，逻辑层面上他们之间需要有一个link。关于这个link，设计的时候可以有以下的几种option：</p><p>Direct or Indirect 在每个process想和别的process进行通信的时候，需要严格说明对方的名称，或者只有sender需要说明对方的名称。这种精确到名字的link一般不太好使用，一旦process的id被update了，这种方法的overhead会非常高。Indirect的link的话，有port做过度。这样的话IPC就不是直接进程对进程，而是两组进程对port。port可以是OS层面的，也可以是进程层面的。<br>Synchronization or Asynchronization 是不是允许sender和receiver 被block？<br>Buffering 是不是允许sender和receiver有一个queue来存储一系列的消息？还是只能够一条一条的发送和接收？<br>Pipe是一种message passing的IPC方法。一个pipe有两端，每一端都是一个file descriptor，一端作为读口，一端作为写口。原始的pipe允许一个进程从其中一端写入，允许另一个进程从另外一端读取。一般来说，原始的pipe的使用场景在于父进程和子进程之间的IPC。首先，父进程创建一个新的pipe，然后调用fork函数创建子进程。这时父进程和子进程同时都有相同的pipe。之后分别关闭掉父进程和子进程中不用的一端，即可完成父进程和子进程之间的写入读取。当然pipe的设计可以有多种option，比如是不是只允许父子进程的通信，或者允许单方向还是双方向。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近节日大爆发，感恩节接着圣诞节，再接着元旦，除了跨年外实在是没有事情做，索性就学习好了。操作系统是一直以来想看的内容，自从大三的时候操作系统课拿了个D，就一直想什么时候重新学一下。好吧那就不要拖延的看起来吧。选择的课本是Abraham Silberschatz的经典之作“Operating System Concepts (10th Edition)”。本篇学习笔记出自于这本书的第三章“Process”。如果有什么地方理解不到位，或者写的不清楚欢迎留言指出，一起进步。&lt;br&gt;
    
    </summary>
    
      <category term="Geek" scheme="http://yoursite.com/categories/Geek/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>日语中表示命令的几种用法区分</title>
    <link href="http://yoursite.com/2018/12/23/02-japcmd/"/>
    <id>http://yoursite.com/2018/12/23/02-japcmd/</id>
    <published>2018-12-24T05:40:03.000Z</published>
    <updated>2019-05-23T04:48:57.277Z</updated>
    
    <content type="html"><![CDATA[<p>标日初级下册的第29课「電気を消せ」中主要讲授了日语中表示命令的几种用法，他们在意思上都大同小异，主要都表示“快去做某事！”，或者“不准做某事！”。初学的时候没怎么在意，直到做了同步练习才发现自己什么都没搞清。。这篇日志主要对这几种用法做一些总结与区分。<br><a id="more"></a> </p><h4 id="直接使用动词的命令型"><a href="#直接使用动词的命令型" class="headerlink" title="直接使用动词的命令型"></a>直接使用动词的命令型</h4><p>命令型的活用规则不再赘述，命令型可以说是语气最强的命令形式，一般是有权力的一方对待没有权力的一方，或者是年长者对待年轻者身上。紧急情况下（比如要求对方注意安全）可以使用。此外，还可以在体育比赛中加油鼓劲或者是男性友人之间劝酒中使用。女性一般不使用这种形式。（以下所有的例子取自于标日同步练习）</p><ul><li>主任：おーい！鈴木！ちょうと来い！　-鈴木：はい、何ですか。　-主任：これを片付けろ！</li></ul><h4 id="使用「動詞＋な」表示禁止"><a href="#使用「動詞＋な」表示禁止" class="headerlink" title="使用「動詞＋な」表示禁止"></a>使用「動詞＋な」表示禁止</h4><p>语气最强表示禁止，或者否定的用法，意思是不要做某事，禁止做某事。</p><p>ここでタバコを吸うな！</p><h4 id="使用「動詞連用形＋なさい」"><a href="#使用「動詞連用形＋なさい」" class="headerlink" title="使用「動詞連用形＋なさい」"></a>使用「動詞連用形＋なさい」</h4><p>语气次强烈表示做某事的用法。可以用在老师对学生，父母对子女身上。常常也会在考试的题目说明中看到「答えなさい」的用法。</p><p>早く起きなさい。遅刻するわよ。</p><h4 id="使用「動詞て形・動詞ない形＋で」"><a href="#使用「動詞て形・動詞ない形＋で」" class="headerlink" title="使用「動詞て形・動詞ない形＋で」"></a>使用「動詞て形・動詞ない形＋で」</h4><p>语气最不强烈的祈使用法，男性女性都可以用，一般用在比较亲密的人身上。</p><p>静かにして。大きな声を出さないで。赤ちゃんが寝たから。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标日初级下册的第29课「電気を消せ」中主要讲授了日语中表示命令的几种用法，他们在意思上都大同小异，主要都表示“快去做某事！”，或者“不准做某事！”。初学的时候没怎么在意，直到做了同步练习才发现自己什么都没搞清。。这篇日志主要对这几种用法做一些总结与区分。&lt;br&gt;
    
    </summary>
    
      <category term="FineArts" scheme="http://yoursite.com/categories/FineArts/"/>
    
    
      <category term="Japanese" scheme="http://yoursite.com/tags/Japanese/"/>
    
  </entry>
  
  <entry>
    <title>CMU好课推荐：15-122 PRINCIPLES OF IMPERATIVE PROGRAMMING</title>
    <link href="http://yoursite.com/2018/10/04/01-cmu15122/"/>
    <id>http://yoursite.com/2018/10/04/01-cmu15122/</id>
    <published>2018-10-05T04:30:10.000Z</published>
    <updated>2019-05-23T04:49:18.789Z</updated>
    
    <content type="html"><![CDATA[<p>安然无恙（其实头发很有恙）的度过了在匹兹堡的第一个学期，能在五门课中活下来证明还是有进步的，即使忙碌的、焦躁的，绝望的日夜占了学期的大多数。要说这学期最喜欢最新奇收获最大的课，我觉得应该是当仁不让的15-122。<br><a id="more"></a> </p><p>迫于淫威，选择了这门不计入毕业学分的本科生level的CS课，全名叫做Principles of Imperative Programming，以教授命令式编程（C）与基本的数据结构为主线，是要declare CS major的学生必修的基础课以及核心课程。所以有200+的学生和30+的TA，并且基本上所有的学生都是first year（first year graduate的我惭愧的低下了头）。</p><p>这门课的workload要比我这学期上的所有其他研究生课程的workload都来的大。每周一交一个written homework（共13次），每周四交一个programming homework（共11次），每周两次lecture，课上会有随机的quiz（计入总分），每周一次lab（计入总分），每周一次recitation，两次midterm和一次final。</p><p>这门课讲了什么呢？首先从最最基础的二进制讲起，然后开始将数据结构与零零散散的东西穿插起来介绍（看到syllabus可以感觉到每节lecture的内容都是精心安排的）。数据结构有介绍了array，stack，queue，linked list，unbounded array，hash tables，set，BST，AVL tree，priority queue，heap，graph，union find等。</p><p>但是这门课不光只是介绍了数据结构，还有很多零零碎碎的东西也被提上了桌面。比如说lecture里有教几种sort和search的方法，命令式编程中的pointer和function pointer，编程时需要尊重client和library的interface，如何写各种test case，使用void*和函数指针写出generic的函数，C的内存模型，undefined behavior，虚拟机等。lab里有着重锻炼书写test case，recitation里还有对lecture内容的补充（比如说用stack实现DFS，课上用的是recursion）。</p><p>我为什么喜欢并推荐这门课呢？</p><p>这门课有两位负责任的instructor。Stephanie虽然上课十句话里有一句讲错，写代码三行里必出错别字，但是上课非常有趣。在实现数据结构的interface的时候，她常常尝试用不同的方法，即使方向是完全错误的，她至少让我们看到了这么实现的弊端在哪里。作为一门CS的基础课，能够做到授之以渔便是最大的成功。Illiano作为这门课的主管，对整个课的质量把控的非常严格，所有的作业基本都是两天内出分，grading能够做到你心服口服。上课的方式也很有趣（貌似本科生的课都很有趣），比如说有一次编程作业是图片变换，有一个bonus的题，想出你最喜欢最美丽的图片变换并写代码。一周后的课堂上突如其来的评选出了top 10送小礼品+送加分。</p><p>这门课的TA非常负责（只能说有一些TA非常负责）。有一次written homework我做的比较差，因为有一道大题没太明白题目意思，于是就去OH准备和TA把分数argue回来，她非常耐心的和我解释每一条扣分点在哪里，把本来打算找他们算账的我说的心服口服。更加负责的是，后来我登录上去我的gradescope，发现她在我在OH问的那些问题的旁边把她的解释完整的加在了备注里，为的是我考试复习的时候比较方便。这是最最最让我感动的一点。还有，midterm2的时候，我因为时间来不及胡乱猜了两三个答案写在试卷上，有两个蒙对了但是TA没给我分。跑过去regrade，ta说一看你就是不会写瞎蒙的，不能给你分。</p><p>课程的设置非常的有foresight。学期初有一次编程作业里的一个task是对图片做高斯模糊，其中的一个步骤是对图片加padding，并且用方格遍历选取最大的元素。后来上到601 CNN的时候，才明白过来原来这就是CNN里的max pooling layer。其他的作业也非常实用，比如说用gap buffer实现text editor，写一个PRNG，使用heap实现huffman tree然后变成一个用来压缩文件的程序（真的可以用来压缩和解压缩文件和图片！），写一个虚拟机的decoder，类似于汇编码的decoder（真的可以用来跑c0文件的bytecode！）。</p><p>很难，很push。push是我对这门课最大的感受。比如说好死好活写了一次programming homework，只占总分里的2.5分，一次written homework只占100分的的1.2分。并且这门课是不curve的，严格按照90分以上是A的标准。真是对于任何一次作业都不敢不好好做（否则一次扣0.5分真的伤不起）。同时，总评的grading还会case by case，意思就是即使总评90+，如果三次考试的平均分不到80%，也会按照B处理。或者是如果programming homework的分数太低，就会收到D的总评，直接剥夺下学期选15-213的权利。这门课的push同时还体现在每次作业限制autolab的提交次数（5-7次），以及coding style的规范，以及有几次的作业需要考虑efficiency，以及有几次的作业是在due之后才会给你评分（意味着无法根据autolab的提示进行debug）。</p><p>整个课程的材料都让我感觉到设置的精心。比如说基本上每次的编程作业，都会提供几百个test case来测试你程序是否有bug。像最后一次作业，他写了350+个的test case来测试你的程序，我觉得这在一般的课程上是做不到的吧。另外，为了上这门课，这门课当初的设计者写了一门新的语言叫做C0。C0是C语言的一个子集，里面剥夺了一些容易让程序失控的特性，比如说casting，比如动态内存的回收，比如指针运算，比如一些ECF（break等）。同时添加了新的数据类型比如string，以及string的操作（以替代神烦的strxxx系列）。为了一门课程直接写一门新语言真的是细想极恐。</p><p>总而言之，15122真的是我到目前为止最满意的CS课（甚至超过15-513），强烈推荐闲的发慌的人去上一波。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安然无恙（其实头发很有恙）的度过了在匹兹堡的第一个学期，能在五门课中活下来证明还是有进步的，即使忙碌的、焦躁的，绝望的日夜占了学期的大多数。要说这学期最喜欢最新奇收获最大的课，我觉得应该是当仁不让的15-122。&lt;br&gt;
    
    </summary>
    
      <category term="Geek" scheme="http://yoursite.com/categories/Geek/"/>
    
    
      <category term="Course" scheme="http://yoursite.com/tags/Course/"/>
    
  </entry>
  
</feed>
