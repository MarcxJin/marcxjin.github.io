<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Marc Jin</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-05-25T07:59:45.878Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Marc Jin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试中常用到的图算法</title>
    <link href="http://yoursite.com/2021/05/24/10/"/>
    <id>http://yoursite.com/2021/05/24/10/</id>
    <published>2021-05-24T17:36:37.579Z</published>
    <updated>2021-05-25T07:59:45.878Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章将解释面试中常用的图算法 —— 关于BST，DFS，BFS等。面试中常用到的图算法基本局限在二叉树相关，以BFS或者DFS的方式对图进行遍历顺便储存相关的DP信息，以topological sort为主要的图顶点排序，还有将不同元素进行归类的union find算法。</p><a id="more"></a><h1 id="Representations-of-the-graph"><a href="#Representations-of-the-graph" class="headerlink" title="Representations of the graph"></a>Representations of the graph</h1><p>二叉树的话很简单，一般使用如下结构表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">    self.val = val</span><br><span class="line">    self.left = left</span><br><span class="line">    self.right = right</span><br></pre></td></tr></table></figure><p>普通图的话，根据题目里所给定的或者需求选用不同的表示方法。假设已经提前知道所有顶点的集合，或者比较方便能够将顶点映射到整数的情况下，推荐使用二维数组。比如顶点是26个英文字母的情况下就可以使用这种方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># graph[i][j] = True 意味着有从i到j的边存在</span></span><br><span class="line">graph = [[<span class="literal">False</span>] * <span class="number">26</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(<span class="number">26</span>))]</span><br></pre></td></tr></table></figure><p>不太好将顶点映射到整数的情况下，或者预先不知道所有顶点的集合而是需要遍历一遍才能构建图的情况下，选择使用HashMap，将顶点作为key。因为是一对多的结构，value所使用的结构可以为list或者set，根据需求进行选择。</p><p>如果反正是要遍历一边endpoint的话，可以选择list简明扼要。如果只需要判断有没有这个边存在，或者是需要快速添加和移除边的话，可以使用set。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> start, end <span class="keyword">in</span> l: <span class="comment"># l = [[1,2], [2,3], [4,5]]</span></span><br><span class="line">  lst = graph.get(start, [])</span><br><span class="line">  lst.append(end)  <span class="comment"># 使用list可能会重复添加边，如果不是simple graph的话</span></span><br><span class="line">  graph[start] = lst</span><br></pre></td></tr></table></figure><h1 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS, BFS"></a>DFS, BFS</h1><p>DFS和BFS为两种遍历图的方法，为深度优先和广度优先。顾名思义，前者会先将某一条路径遍历到底，再寻找另一条路径。而后者是根据离出发点的先后顺序，先遍历完最近的那些点，再一层一层往外铺开。</p><p>一般情况下两者是可以通用的。但如果是要寻找从某一点出发的最短路径，那么BFS无论从理论上还是从实际的算法复杂度上都似乎更加合适。</p><p>DFS常用recursion和iterative两种方法。recursion的话，根据任务的要求，我们一般可以在三个地方加上自己的逻辑来解题，一为刚访问这个点的时候，二为将这个点所有的邻边都访问完的时候，三为返回和这个点相关的数值或者布尔值，通常用在dp问题里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">visited = set()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">visited.add(node)</span><br><span class="line">    <span class="comment"># 1</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> graph[node]:</span><br><span class="line">      dfs(end)</span><br><span class="line">    <span class="comment"># 2</span></span><br><span class="line">  <span class="comment"># 3: return xxx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> graph:</span><br><span class="line">  dfs(key) <span class="comment"># treat every node as start point, so that we visit the stand-alone part</span></span><br></pre></td></tr></table></figure><p>iterative的话，dfs的结构更像stack，所以我们使用stack。这个方法一般用于单source的题目中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start, graph)</span>:</span></span><br><span class="line">  stack = []</span><br><span class="line">  stack.append(start)</span><br><span class="line">  <span class="keyword">while</span> stack:</span><br><span class="line">    node = stack.pop()</span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">in</span> graph:</span><br><span class="line">      <span class="keyword">for</span> end <span class="keyword">in</span> graph[node]:</span><br><span class="line">        stack.append(node)</span><br></pre></td></tr></table></figure><p>BFS则一般使用iterative的方法，和DFS不同，我们使用queue，因为先加入的（离原点近的）需要先被遍历完，再遍历远的（FIFO）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(start, start)</span>:</span></span><br><span class="line">queue = []</span><br><span class="line">  queue.append(start)</span><br><span class="line">  <span class="keyword">while</span> queue:</span><br><span class="line">    node = queue.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">in</span> graph:</span><br><span class="line">      <span class="keyword">for</span> end <span class="keyword">in</span> graph[node]:</span><br><span class="line">        queue.append(end)</span><br></pre></td></tr></table></figure><p>在BST中使用DFS或者BFS的时候则简单的多，只要分别check当前node的left和right是否为None再依次遍历就行了。</p><h1 id="Cycle-Detection"><a href="#Cycle-Detection" class="headerlink" title="Cycle Detection"></a>Cycle Detection</h1><p>如果一个图有cycle的话，那么从某个点出发，还没有访问完这个点为源点的所有边，就又会碰到这个点，故此使用DFS更为合理。这里的关键是，刚访问到这个点的时候，mark他，然后访问完所有的边之后，再unmark他。这个mark的数据结构，根据构建的简易性，访问的复杂度可以使用数组或者hashset。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_cycle</span><span class="params">(graph)</span>:</span></span><br><span class="line">  visited = set()</span><br><span class="line">  in_stack = set() <span class="comment"># 这里的visited和inStack均适用set，比较直观</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_cycle_util</span><span class="params">(node)</span>:</span></span><br><span class="line">    visited.add(node)</span><br><span class="line">    in_stack.add(node)  <span class="comment">#标记我们开始访问这个点</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> node <span class="keyword">in</span> graph:</span><br><span class="line">      <span class="keyword">for</span> end <span class="keyword">in</span> graph[node]:</span><br><span class="line">        <span class="keyword">if</span> end <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> is_cycle_util(end):</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> end <span class="keyword">in</span> visited <span class="keyword">and</span> end <span class="keyword">in</span> in_stack:  <span class="comment"># We encounter this node again</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    in_stack.remove(node) <span class="comment">#  移除，表示我们已经访问完毕</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> key <span class="keyword">in</span> graph:</span><br><span class="line">    <span class="keyword">if</span> is_cycle_util(key):</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h1><p>拓扑排序是基于有向边图的一种排序方法，拓扑排序出来的结果表示着有向图的起点一定会排在终点之前，结果常常不唯一。故这个排序方法可能用来理清需求关系，比如理清一系列dependents的先后顺序。</p><p>拓扑排序常常有两种方法，第一种是贪心算法。从入度为0的顶点开始删边，删完之后将这个顶点放入拓扑排序的结果之中。然后在子图上重复这个步骤。这种方法同样也能检测cycle，因为正常情况下最后图里应该没有顶点也没有边了，但是cycle的情况下，最后还会有顶点在图里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topological_sort_greedy</span><span class="params">(graph)</span>:</span></span><br><span class="line">  in_degree = &#123;&#125;</span><br><span class="line">  result = []</span><br><span class="line">  <span class="keyword">for</span> vertice <span class="keyword">in</span> graph: <span class="comment"># we assume every vertice will be the key of the graph dict</span></span><br><span class="line">    in_degree[vertice] = len(graph[vertice])</span><br><span class="line">  stack = []</span><br><span class="line">  <span class="keyword">for</span> key <span class="keyword">in</span> in_degree:</span><br><span class="line">    <span class="keyword">if</span> in_degree[key] == <span class="number">0</span>: stack.append(key)</span><br><span class="line">  <span class="keyword">while</span> stack:</span><br><span class="line">    v = stack.pop()</span><br><span class="line">    result.append(v)</span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> graph[v]:</span><br><span class="line">      in_degree[end] = in_degree[end] - <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> in_degree[end] == <span class="number">0</span>:</span><br><span class="line">        stack.append(end)</span><br><span class="line">   <span class="comment"># cycle detection, no need if not needed</span></span><br><span class="line">  <span class="keyword">for</span> key <span class="keyword">in</span> in_degree:</span><br><span class="line">    <span class="keyword">if</span> in_degree[key] &gt; <span class="number">0</span>:  <span class="comment"># 如果还有未删完的边，则存在cycle</span></span><br><span class="line">      print(<span class="string">"cycle detected."</span>)</span><br><span class="line">   <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>另外一种则是DFS，把以一个顶点为开始所有的边全部都遍历之后，再加入最后的拓扑排序中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topological_sort_dfs</span><span class="params">(graph)</span>:</span></span><br><span class="line">  result = []</span><br><span class="line">  visited = set()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">      visited.add(node)</span><br><span class="line">      <span class="keyword">for</span> end <span class="keyword">in</span> graph[node]:</span><br><span class="line">        dfs(end)</span><br><span class="line">      result.append(node)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> v <span class="keyword">in</span> graph:</span><br><span class="line">    dfs(v)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>当我们使用DFS的时候，我们也可以改进算法，让他也具备有检测cycle的功能。（一般说来，面试题不会假定没有cycle，所以写出来的算法最好也要有检测cycle的功能）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的代码结合了上面的topological_sort_dfs和之前的is_cycle</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_with_cycle_detection</span><span class="params">(graph)</span>:</span></span><br><span class="line">  result = []</span><br><span class="line">  visited = set()</span><br><span class="line">  in_stack = set()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">should_append = node <span class="keyword">not</span> <span class="keyword">in</span> visited</span><br><span class="line">    visited.add(node)</span><br><span class="line">    in_stack.add(node)</span><br><span class="line">    ret = <span class="literal">False</span></span><br><span class="line">   <span class="keyword">for</span> end <span class="keyword">in</span> graph[node]:</span><br><span class="line">      <span class="keyword">if</span> end <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> dfs(end):</span><br><span class="line">        ret = <span class="literal">True</span></span><br><span class="line">      <span class="keyword">if</span> end <span class="keyword">in</span> visited <span class="keyword">and</span> node <span class="keyword">in</span> in_stack:</span><br><span class="line">        ret = <span class="literal">True</span></span><br><span class="line">    in_stack.remove(node)</span><br><span class="line">    <span class="keyword">if</span> should_append:</span><br><span class="line">      result.append(node)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> key <span class="keyword">in</span> graph:</span><br><span class="line">    <span class="keyword">if</span> dfs(key):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># cycle detected</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># cycle not detected, and result[::-1] is the sort result</span></span><br></pre></td></tr></table></figure><h1 id="Union-Find"><a href="#Union-Find" class="headerlink" title="Union Find"></a>Union Find</h1><p>Union find 可以把元素分成互不相交的几个集合，比如说leetcode的第721题就是一个典型的例子。做union find的时候，首先要把每个元素进行编号（我们使用list based的方法实现union find，比tree based的方法更容易用在面试中）。最后做完union find之后，还要能够轻易的访问到每个元素以此进行归类：你可以使用hashmap，也可以直接遍历id的幅值范围。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union_find</span><span class="params">()</span>:</span></span><br><span class="line">  p = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)] <span class="comment"># 每个元素i都指向自己，此时有100个disjoint set</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment"># 如果x不是当前的代表元素，一个个顺着往上找，并且全部直接更新到父元素，这叫做path compression</span></span><br><span class="line">    <span class="keyword">if</span> p[x] != x:</span><br><span class="line">      p[x] = find(p[x])</span><br><span class="line">    <span class="keyword">return</span> p[x]</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="comment"># 把x元素的根结点指向y元素的根结点，相当于merge两个集合。</span></span><br><span class="line">    <span class="comment"># 在更加优化的算法里，经常还需要看rank来决定把谁并到谁里面去。</span></span><br><span class="line">    p[find(x)] = find(y)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章将解释面试中常用的图算法 —— 关于BST，DFS，BFS等。面试中常用到的图算法基本局限在二叉树相关，以BFS或者DFS的方式对图进行遍历顺便储存相关的DP信息，以topological sort为主要的图顶点排序，还有将不同元素进行归类的union find算法。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>N3文法总结</title>
    <link href="http://yoursite.com/2021/05/09/09_n3/"/>
    <id>http://yoursite.com/2021/05/09/09_n3/</id>
    <published>2021-05-09T07:40:59.735Z</published>
    <updated>2021-05-09T07:41:07.804Z</updated>
    
    <content type="html"><![CDATA[<p>N3常用语法总结。</p><a id="more"></a><h1 id="动词连用形接续相关"><a href="#动词连用形接续相关" class="headerlink" title="动词连用形接续相关"></a>动词连用形接续相关</h1><h2 id="「V連用」＋始める・終わる・出す・続ける"><a href="#「V連用」＋始める・終わる・出す・続ける" class="headerlink" title="「V連用」＋始める・終わる・出す・続ける"></a>「V連用」＋始める・終わる・出す・続ける</h2><p>表示开始做某事（这个某事通常是费时费力的），结束做某事和突然出现某种情况。</p><blockquote><p><strong>日本語を習い始めたのは半年前です。</strong><br><strong>その本、読み終わったら貸してもらえませんか。</strong><br>あの人は歯医者に一年以上通い続けれいるそうです。</p></blockquote><h1 id="动词被动形态活用相关"><a href="#动词被动形态活用相关" class="headerlink" title="动词被动形态活用相关"></a>动词被动形态活用相关</h1><h2 id="ように言われた"><a href="#ように言われた" class="headerlink" title="~ように言われた"></a>~ように言われた</h2><p>表示命令，禁止，建议或者指导。</p><blockquote><p>先生に宿題を忘れないように注意された。<br>医者にお酒を飲まないように言われました。</p></blockquote><h2 id="られてしまう"><a href="#られてしまう" class="headerlink" title="られてしまう"></a>られてしまう</h2><p>表示认为别人做的事情很困扰或者很迷惑。</p><blockquote><p>言葉が足りないと、誤解されてしまうことがある。</p></blockquote><h1 id="动词使役-使役被动）形态活用相关"><a href="#动词使役-使役被动）形态活用相关" class="headerlink" title="动词使役(使役被动）形态活用相关"></a>动词使役(使役被动）形态活用相关</h1><h2 id="させてもらう・させてくれる"><a href="#させてもらう・させてくれる" class="headerlink" title="させてもらう・させてくれる"></a>させてもらう・させてくれる</h2><p>得到某人的允许做某事，表达感激之情。</p><blockquote><p>この会社は自分の意見を自由に言わせてくれる。<br>高校生の時、アルバイトをしたいと母に言ったが、させてもらえなかった。</p></blockquote><h2 id="させられた"><a href="#させられた" class="headerlink" title="させられた"></a>させられた</h2><p>表示别人让你做某事，你不得不做某事。</p><blockquote><p>子供の時テストの成績が悪いと、父にトイレ掃除をさせられた。</p></blockquote><h1 id="动词构词"><a href="#动词构词" class="headerlink" title="动词构词"></a>动词构词</h1><h2 id="「がる」"><a href="#「がる」" class="headerlink" title="「がる」"></a>「がる」</h2><p>表示第三人称的心情想法。加一类形容词的时候去「い」加。二类形容词和名词的时候直接加。加动词的时候一般只加「Vたい」，此时构词发类似于一类形容词。</p><blockquote><p>彼は試合に負けて悔しがっている。　（悔しがる）<br>わからない言葉があったら、面倒がらないですぐに調べない。　（面倒がる）<br>寒い日は猫も外へ出たがらない。　（出たがる）</p></blockquote><p>使用「がり」的时候一般表示怎样怎样的人，比如「怖がり」指的是容易害怕的人。</p><h2 id="「おく」"><a href="#「おく」" class="headerlink" title="「おく」"></a>「おく」</h2><ul><li>表示为某事做准备。</li><li>表示放任，持续某个状态。</li></ul><blockquote><p>あとで使うから、このまま置いておいます。</p></blockquote><ul><li>持续做某事，不要中止当前动作，常用于比自己地位低的人。</li></ul><blockquote><p>夏に車の中で子供を待たせておくのは危険ですよ。</p></blockquote><h2 id="「に決まっている」"><a href="#「に決まっている」" class="headerlink" title="「に決まっている」"></a>「に決まっている」</h2><p>表示非常肯定某件事。</p><blockquote><p> 夏は暑いに決まっているでしょう。</p></blockquote><h2 id="「による・によって」"><a href="#「による・によって」" class="headerlink" title="「による・によって」"></a>「による・によって」</h2><p>表示某人完成某事所使用的方法。利用，通过。</p><blockquote><p>大学はアンケットによる満足度調査の結果を発表した。<br>我が社は社内の公用語を英語にすることによって、国際化を目指している。</p></blockquote><p>「によって」使用在被动句中的时候表示发明创造的主体。<br>「ニュートンによって定理が発見する。」</p><p>还能够表示原因，理由。表示因果关系。</p><blockquote><p>今回の大事故はスピードのだし過ぎによるものだそうだ。<br>海外生活を経験したことによって、視野が広がった。</p></blockquote><p>还能表示事物根据人，地点，时间的不同而不同。</p><blockquote><p>いろいろな人がいるのだろう、人によって好みや考え方が違うのは当然だ。<br>この薬は人によっては副作用が照ることがあります。</p></blockquote><h2 id="「によると・によれば」"><a href="#「によると・によれば」" class="headerlink" title="「によると・によれば」"></a>「によると・によれば」</h2><p>特别表示通过什么途径知道了信息和情报。</p><blockquote><p>最近の調査によれば、病気じゃないが不健康な人が増えているそうだ。</p></blockquote><h2 id="「に対して（は・も）・に対する」"><a href="#「に対して（は・も）・に対する」" class="headerlink" title="「に対して（は・も）・に対する」"></a>「に対して（は・も）・に対する」</h2><p>表示情感或者动作的对象。后面加は・も的时候表示强调，也。</p><blockquote><p>彼女は誰に対しても親切です。<br>目上の人に対しては敬語を使いましょう。<br>この病気に対する効果的な治療法はまだ見つかっていない。</p></blockquote><h2 id="「につき」"><a href="#「につき」" class="headerlink" title="「につき」"></a>「につき」</h2><p>表示每个单位限定的数量。</p><blockquote><p>1回につき2000円　（一次两千日元）<br>ご利用はお一人につき三十分までとなっております。</p></blockquote><h2 id="「について」"><a href="#「について」" class="headerlink" title="「について」"></a>「について」</h2><p>提示主题。关于。</p><blockquote><p>兄は大学院で、アジアの経済について研究してます。</p></blockquote><h2 id="「を通して・を通じて」"><a href="#「を通して・を通じて」" class="headerlink" title="「を通して・を通じて」"></a>「を通して・を通じて」</h2><p>表示不直接做某事，而通过某种方法。</p><blockquote><p>現在はインターネットを通して、すぐに世界中にニュースが広まる。</p></blockquote><p>前面接时间相关的名词，比如一年，四季，一生的时候，表示后面的事贯穿了整个时间。</p><blockquote><p>工場内は年間を通じて、気温、温度が一定に保たれています。</p></blockquote><h2 id="「きる」"><a href="#「きる」" class="headerlink" title="「きる」"></a>「きる」</h2><p>表示全部做完，竭尽；也可以表示非常。</p><blockquote><p>地球上には数え切れないほど多くの生物がいる。<br>父はずっと残業が続いていて、疲れ切った顔をしている。　</p></blockquote><h2 id="「というと・といえば・といったら」"><a href="#「というと・といえば・といったら」" class="headerlink" title="「というと・といえば・といったら」"></a>「というと・といえば・といったら」</h2><p>说到什么的话，～～。经常用于提示著名的或具有代表性的食物。</p><blockquote><p>日本の花というと、桜がすぐ頭に浮かぶ。<br>冬のスポッツと言ったら、やはりスキーだよね。</p></blockquote><p>如果使用「ことといったら」，则表示一种惊讶，感动或者愤怒的语气（加强语气）。</p><blockquote><p>あの店の店員の態度のひどいことといったら。。。もう二度と行きたくない。</p></blockquote><h2 id="「にとって」"><a href="#「にとって」" class="headerlink" title="「にとって」"></a>「にとって」</h2><p>表示站在某人的立场上来说，后面经常接着难，重要等评价性的形容词。不能接态度性的形容词。</p><blockquote><p>今回の旅行は私にとって忘れられない思い出になるだろう。</p></blockquote><h2 id="「しかない」"><a href="#「しかない」" class="headerlink" title="「しかない」"></a>「しかない」</h2><p>表示“只能这样了，没办法了”。同「ほかない」。</p><blockquote><p>入学試験まであと一週間、とにかく頑張るしかありません。<br>全員が集まれるのは、金曜の午後しかありませんね。</p></blockquote><h2 id="「とは限らない」"><a href="#「とは限らない」" class="headerlink" title="「とは限らない」"></a>「とは限らない」</h2><p>不限于，不仅仅是，否定常用印象的套用范围。</p><blockquote><p>最近、バレンタインデーに贈るものはチョコレートとは限らないそうです。<br>大企業だからといって、倒産しないとは限らない。</p></blockquote><h2 id="「たりして」"><a href="#「たりして」" class="headerlink" title="「たりして」"></a>「たりして」</h2><ul><li><p>表示可能，和「かもしれない」同意。</p></li><li><p>委婉的说别人的样子和普通不一样。</p><blockquote><p>どうしたの？着物着たりして、どこに行くの？</p><p>今日は友達の結婚式なの。</p></blockquote></li><li><p>给出指示。</p><blockquote><p>ここは図書館ですから、大きい声で話したりしないでください。</p></blockquote><h2 id="「かと思った」"><a href="#「かと思った」" class="headerlink" title="「かと思った」"></a>「かと思った」</h2><p> 表示当初是这么想的，但最后发现是错误的。</p><blockquote><p>10キロも走らされて、死ぬかと思ったよ。</p></blockquote></li></ul><h2 id="「ついでに」"><a href="#「ついでに」" class="headerlink" title="「ついでに」"></a>「ついでに」</h2><p>前面加动词肯定简体形，或者名词+の，也可以直接单独使用，表示顺便。 </p><blockquote><p>薬局へ薬を買いに行った<strong>ついでに</strong>、トイレートペーパーモ買ってきた。</p><p>ちょっとコンビニ行ってくる。　じゃあ、<strong>ついでに</strong>パン、買ってきて。</p></blockquote><h2 id="「に違いない・に相違ない」"><a href="#「に違いない・に相違ない」" class="headerlink" title="「に違いない・に相違ない」"></a>「に違いない・に相違ない」</h2><p>表示绝对肯定某件事。</p><blockquote><p>この絵を描くのに何百時間もかかったに違いないと思う。</p></blockquote><h2 id="「ぬきで」"><a href="#「ぬきで」" class="headerlink" title="「ぬきで」"></a>「ぬきで」</h2><p>汉字写成「抜きで」，前面加名词，表示除去前者怎么样怎么样。</p><blockquote><p>今日の忘年会は仕事の話ぬきで楽しみましょう。</p></blockquote><h1 id="名词构词"><a href="#名词构词" class="headerlink" title="名词构词"></a>名词构词</h1><h2 id="「ほど」"><a href="#「ほど」" class="headerlink" title="「ほど」"></a>「ほど」</h2><p>「ほど」表示什么样的程度，前面加简体小句。有时动词也用连用形。</p><blockquote><p>富士山に登って、降りて来た時は、もう一歩も歩けないほど疲れていた。<br>今週中にやらなければならない仕事が山ほどある。</p></blockquote><p>「ほど」后面加上「ない」表示不如什么的程度。</p><blockquote><p>留学生活は心配していたほど大変じゃなかった。</p></blockquote><p>「ほど」后面加上「ない」也可以表示前者是最高程度的后者。</p><blockquote><p>雷が鳴っている時に高い木の下にいることほど危険なことはない。</p><p>夏は毎年暑いけど、今年ほど暑い夏はないんじゃないかなあ。</p></blockquote><h2 id="「とたん（に）」"><a href="#「とたん（に）」" class="headerlink" title="「とたん（に）」"></a>「とたん（に）」</h2><p>「とたん（に）」可以表示一怎么样就怎么样，汉字写成「途端」。由于前面的事情为已经发生的事情，接动词「た形」。后面不能接说话者的意志，比如一长大就想做什么。</p><blockquote><p>立ち上がったとたん、目の前が暗くなった。<br>彼女はさっきまで元気がなかったのに、ご飯を食べたとたん元気になった。</p></blockquote><h2 id="「じゃない」"><a href="#「じゃない」" class="headerlink" title="「じゃない」"></a>「じゃない」</h2><p>表示用于确认对方知道这件事，或者有着相同的观点，或者发表意见或责备的时候使用。不是否定的意思，语调要下降。此时同样可以用「じゃん」。</p><blockquote><p>あそこは交通の便もいいじゃない。　（是否有相同观点）<br>駅前に新しいコンビニができたじゃないですか。　（确认）<br>ー宿題忘れちゃった。　ーだめじゃない。　（表示责难）</p></blockquote><h2 id="「ばかり」"><a href="#「ばかり」" class="headerlink" title="「ばかり」"></a>「ばかり」</h2><ul><li>表示光做某事，只做某事，含有责备的含义。前面加名词或者动词的て形。也可以使用简体或者ている。也常常使用「ばかりいる」。</li></ul><blockquote><p>最近雨ばかりで、洗濯物が乾かなくて困っています。<br>逃げてばかりじゃ勝てないぞ。</p></blockquote><ul><li>表示心理上的刚刚，即使时间上已经过了很长时间、只要是说话人觉得没过多久。前面用动词的「た」形。</li></ul><blockquote><p>父は昨日退院したばかりなのに、今日から会社に出ている。<br>まだ日本語を習い始めたばかりだから。</p></blockquote><h2 id="「ばがりでなく」"><a href="#「ばがりでなく」" class="headerlink" title="「ばがりでなく」"></a>「ばがりでなく」</h2><p>不仅仅是，等同于「だけでなく」。有时也用「ばかりか」。</p><h2 id="「ため（に）」"><a href="#「ため（に）」" class="headerlink" title="「ため（に）」"></a>「ため（に）」</h2><p>表原因，后面不接意志形或者自己的想法。只表示客观原因。“由于”</p><blockquote><p>雨のためにハイキングは中止になりました。<br>外国人観光客が増えたため、外国語のパンフレットを作ることになった。</p></blockquote><h2 id="「とおり」"><a href="#「とおり」" class="headerlink" title="「とおり」"></a>「とおり」</h2><p>正如。如某人所预测。也用「名詞どおり」的形式。</p><blockquote><p>今日の映画は本当に面白かった、友達が言ったとおりだった。</p></blockquote><h2 id="「かわりに」"><a href="#「かわりに」" class="headerlink" title="「かわりに」"></a>「かわりに」</h2><p>代替别人做一些事情。也表示交换条件，以什么什么为代价。</p><blockquote><p>母の帰りが遅くなる日は、母の代わりに私が夕食を作ることになっている。<br>私は便利な生活を手に入れた代わりに、多くの自然を失った。</p></blockquote><h2 id="「たまま・形容詞まゝ」"><a href="#「たまま・形容詞まゝ」" class="headerlink" title="「たまま・形容詞まゝ」"></a>「たまま・形容詞まゝ」</h2><p>表示普通的状态保持，或者不合理的状态保持。</p><blockquote><p>すぐに戻ってきますから、机の上はこのままにしておいてください。<br>日本では卵を生のまま食べると言うのは本当ですか。<br>新しいまま撮っておくつもりです。</p></blockquote><h2 id="「ところ」"><a href="#「ところ」" class="headerlink" title="「ところ」"></a>「ところ」</h2><p>表示动作进行到的一个阶段。后续如果加「を」则一般使用被动。</p><blockquote><p>あくびしたところを写真に撮られたって、佐藤さん怒ってたよ。</p></blockquote><h2 id="「おかげ」"><a href="#「おかげ」" class="headerlink" title="「おかげ」"></a>「おかげ」</h2><p>表示原因，带有感激感谢的意思。托您的福。</p><blockquote><p> おかげさまで。<br> 子供の病気が治ったのは山下先生のおかげです。<br> みんなが手伝ってくれたおかげで、引っ越しが早く済んだ。</p></blockquote><h2 id="「べき」"><a href="#「べき」" class="headerlink" title="「べき」"></a>「べき」</h2><p>应该。如果表示不应该，用后否定「べきではない」。<br>べき前面接动词肯定字典形，后面直接接名词。「するべき」常常也用「すべき」。<br>「べきだった」的话，表示应该这么做却没有，带有后悔的意思。</p><blockquote><p>やるべきことは全てやったんだから、自信を持って試合に望めばいいよ。</p></blockquote><h2 id="「たび（に）」"><a href="#「たび（に）」" class="headerlink" title="「たび（に）」"></a>「たび（に）」</h2><p>表示一个事每次必定会发生，当执行某个动作的时候。</p><blockquote><p>父は主張のたびにお土産を買ってきてくれる。</p></blockquote><h2 id="「はず」"><a href="#「はず」" class="headerlink" title="「はず」"></a>「はず」</h2><p>表示一定，带有一点肯定性。毫无疑问的。</p><blockquote><p>会議は五時までですから、すぐ終わるはずです。</p></blockquote><h2 id="「うちに」"><a href="#「うちに」" class="headerlink" title="「うちに」"></a>「うちに」</h2><p>表示在做什么的过程中，自然而然发生了怎么样的变化。</p><blockquote><p>今はまだ上手じゃなくても練習を重ねる<strong>うちに</strong>できるようになるよ。<br>留守にしている<strong>うちに</strong>、庭に雑草が生えてしまった。</p></blockquote><p>表示在某事发生之前，做某事的命令（应当做），请求（请别人做）或者意志（想要自己做）。和「前に」类似但是不能表示陈述。</p><blockquote><p>アイスクリームが溶けないうちに食べよう。<br>銀行が開いているうちに振り込みに行かなければならない。</p></blockquote><p>注意到「うちに」前面的小句陈述的是想要达成的目的，比如说上面的第一个例句是“在冰淇淋化之前吃掉”， 但是前面用的是，“冰淇淋不化”。 这个句型一般也不用动词原形，而是用「ている」。</p><h2 id="「向け」"><a href="#「向け」" class="headerlink" title="「向け」"></a>「向け」</h2><p>针对特定的人，面向特定的人。如果想表示【适合某个人群】，用「向き」。</p><blockquote><p>これは子供向けの映画だが、大人にも人気がある。</p></blockquote><h2 id="「最中に」"><a href="#「最中に」" class="headerlink" title="「最中に」"></a>「最中に」</h2><p>在做某事的途中，发生了什么意想不到的事情，表达被打扰了。</p><blockquote><p>引っ越しの最中に飼っている犬が逃げ出して、大騒ぎになった。<br>データを入力している最中に、コンピューターがフリーズしまった。</p></blockquote><h2 id="「かけ」"><a href="#「かけ」" class="headerlink" title="「かけ」"></a>「かけ」</h2><p>前面接动词的连用形，表示开始做了某事但还没结束的状态。</p><blockquote><p>弟の部屋には作りかけのプラモデルがいくつもある。<br>図書館で借りた本、まだ読みかけだったのに返却日になってしまった。</p></blockquote><h2 id="「わけがない」"><a href="#「わけがない」" class="headerlink" title="「わけがない」"></a>「わけがない」</h2><p>表达强烈的否定。同「はずがない」，但后者稍微偏客观一些， 表理应。</p><blockquote><p>相手は世界でトップのチームだし、頑張ったって、勝てるわけがない。<br>ずっと行きたがってたんだから、あの人が断るはずがないよ。</p></blockquote><h2 id="「なんか」"><a href="#「なんか」" class="headerlink" title="「なんか」"></a>「なんか」</h2><p>表示“等”，等同于「など」。或者表示说一些不重要的事物-“什么的”。和「なんて」是一个意思。</p><blockquote><p>テレビなんかなくても、パソコンがあれば困らない。</p></blockquote><p>「なんかいない」或者「なんかいられない」则表示“xxx什么的不是真的”。前面接动词て形。</p><blockquote><p>泣いてなんかいません。目にゴミが入っただけです。</p><p>年末はい忙しくて、のんびり昼ご飯を食べてなんかいられないんです。</p></blockquote><p>如果前面要接形容词，则变为其「く」形，然后使用「なんかない」。或者如果要接名词和形容动词，则使用远行，然后使用「なんかじゃない」。</p><h2 id="「っこない」"><a href="#「っこない」" class="headerlink" title="「っこない」"></a>「っこない」</h2><p>和「わけがない」一样表示绝不可能，接续的时候前面加动词连用形。</p><blockquote><p>30年後、自分がどこで何をしているかは誰にもわかりっこない。</p></blockquote><h2 id="「くせに」"><a href="#「くせに」" class="headerlink" title="「くせに」"></a>「くせに」</h2><p>当表达对别人有一种不好的印象，也可以用来表示一种轻度的情绪。也说「そのくせ」。</p><blockquote><p>「今すぐ行きます」って言ったくせに、1時間経ってもこない。</p><p>木村さんはもんぐばかり言う。そのくせ何もしない。</p></blockquote><h2 id="「っぽい」"><a href="#「っぽい」" class="headerlink" title="「っぽい」"></a>「っぽい」</h2><p>一种接尾辞，将名词形容词化，表示像什么什么一样的。</p><blockquote><p>いつも黒っぽい服を着っているね。明るい色は嫌いの？</p></blockquote><h2 id="「〜気味」"><a href="#「〜気味」" class="headerlink" title="「〜気味」"></a>「〜気味」</h2><p>表示当前的状态有种什么什么感的时候使用。前面直接加名词，或者动词连用形。</p><blockquote><p>このところ残業続きで、寝不足気味だから、今日は早く帰るよ。</p><p>経済生息の効果が現れず、大統領の支持率が下がり気味だ。</p></blockquote><h2 id="「〜さえ」"><a href="#「〜さえ」" class="headerlink" title="「〜さえ」"></a>「〜さえ」</h2><p>表示“就连”，用于举出一个极端的例子，以此说明“别的情况也理所应当这样了”。前面加动词て形或者加名词。注意如果有任何助词，需要加在さえ前面。如果要做否定，则一般使用后置否定。</p><blockquote><p>りんさんは友達にさえ何も言わずに急に帰国してしまった。どうしたんだろう。</p><p>彼は自分が騙されたことに気づいてさえいないらしいね。</p></blockquote><h2 id="「くらい」"><a href="#「くらい」" class="headerlink" title="「くらい」"></a>「くらい」</h2><p>表示程度，按照名词进行前面的接续，但是可以直接接名词而不使用「の」连接，也可以使用「ぐらい」的形式。这个表达相比「ほど」更带有一种不寻常，或者最少的程度的意味。</p><blockquote><p>昨日の地震は、座っていられないくらい強く揺れた。</p><p>何度も連絡したのに、いくら時間がなくても、メールを見るぐらいできたでしょう。</p></blockquote><h2 id="「っぱなし」"><a href="#「っぱなし」" class="headerlink" title="「っぱなし」"></a>「っぱなし」</h2><p>表示继续做什么事，或者留着什么事的状态不去管的话不太好。前面使用动词连用形。</p><blockquote><p>自転車を駅前に置きっぱなしにしたら、持っていかれてしまった。</p><p>田中さんは、もう1時間もカラオケで歌いっぱなしだ。</p></blockquote><h2 id="「だらけ」"><a href="#「だらけ」" class="headerlink" title="「だらけ」"></a>「だらけ」</h2><p>前面接表示脏东西或者错误的名词，表示强调“脏”或者“错误”的概念和样态。</p><blockquote><p>雨の日にサッカーの試合をしたので、ユニフォームも靴も泥だらけになった。</p><p>医学的に見たら、間違いだらけのダイエット方法が多いらしい。</p></blockquote><h2 id="「-て＋しょうがない・仕方がない・たまらない」"><a href="#「-て＋しょうがない・仕方がない・たまらない」" class="headerlink" title="「 て＋しょうがない・仕方がない・たまらない」"></a>「 て＋しょうがない・仕方がない・たまらない」</h2><p>前面加表示身体或者精神状态的形容，表示这个人太怎么怎么样以至于不能做某事。</p><blockquote><p>空気が乾燥しているせいか、喉が渇いてしょうがない。</p><p>前から欲しくてしょうがなかったギターがやっと買えた。</p></blockquote><h1 id="「よう」「みたい」「そう」「らしい」的用法"><a href="#「よう」「みたい」「そう」「らしい」的用法" class="headerlink" title="「よう」「みたい」「そう」「らしい」的用法"></a>「よう」「みたい」「そう」「らしい」的用法</h1><h2 id="「よう」的用法"><a href="#「よう」的用法" class="headerlink" title="「よう」的用法"></a>「よう」的用法</h2><h3 id="推测"><a href="#推测" class="headerlink" title="推测"></a>推测</h3><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><h3 id="比喻"><a href="#比喻" class="headerlink" title="比喻"></a>比喻</h3><blockquote><p>あの鉛筆のような形をしている建物は、電話会社のビルです。<br>我が社の新しいロボットはまるで人間のように手足が自由に動きます。<br>山のようにたくさん<br>飛ぶように売れる</p></blockquote><p>简体小句加上「かのように」表示仿佛，宛如，表示像某个不是真实的事情。</p><blockquote><p>りんさんの部屋はまるで泥棒が入ったかのように散らかっている。<br>４月なのにまるで冬に戻ったかのような寒い日が続いている。</p></blockquote><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="「のように・のような」"><a href="#「のように・のような」" class="headerlink" title="「のように・のような」"></a>「のように・のような」</h4><p>提示一个典型的例子。</p><blockquote><p>インフルエンザのような他の人にうつる病気になったら、治るまで学校へ来てはいけないことになっています。</p></blockquote><h3 id="指代"><a href="#指代" class="headerlink" title="指代"></a>指代</h3><h4 id="「Vる」ように言う"><a href="#「Vる」ように言う" class="headerlink" title="「Vる」ように言う"></a>「Vる」ように言う</h4><p>这个用法的词源其实是「Vる」ようにする。他表示的其实是刻意提醒，像这样做，是带有命令，禁止，建议的语气的。也常常用被动表示被说了，被要求了。</p><blockquote><p> <strong>母に宿題を忘れないように言われました。</strong><br> <strong>先生に遅刻しないように注意されました。</strong><br> <strong>お母さんからも勉強するように言ってください。</strong></p></blockquote><h2 id="「みたい」的用法"><a href="#「みたい」的用法" class="headerlink" title="「みたい」的用法"></a>「みたい」的用法</h2><h3 id="推量，推测"><a href="#推量，推测" class="headerlink" title="推量，推测"></a>推量，推测</h3><blockquote><p>新しくできた美術館、人気あるみたいだね。もう行った？</p></blockquote><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><blockquote><p>ピアノみたいに大きくて重い物があると、引っ越しが大変だね。</p></blockquote><h2 id="「そう」的用法"><a href="#「そう」的用法" class="headerlink" title="「そう」的用法"></a>「そう」的用法</h2><h3 id="「連用」＋そう"><a href="#「連用」＋そう" class="headerlink" title="「連用」＋そう"></a>「連用」＋そう</h3><p>そう的第一个用法表示“看上去”，此时前面的动词，形容词应该使用连用形。</p><blockquote><p><strong>雨が降りそうだね。</strong><br><strong>この本は簡単そうです。</strong></p></blockquote><p>表示看上去不怎么样的时候，一类形容词的词尾「くない」，以及二类形容词和名词的词尾「じゃない」应该分别变成「くなさそうだ」和「じゃないさそうだ」。而动词则大多使用「動詞連用＋そうもない・そうにない・そうにもない」的形式。</p><blockquote><p>こんな難しそうな本、一週間では読めそうもない。<br>この仕事はそんなに大変じゃなさそうだ。</p></blockquote><h1 id="简体-省略"><a href="#简体-省略" class="headerlink" title="简体 省略"></a>简体 省略</h1><p>主要都是「て形」时接续的省略。<br>「ている」「でいる」→「てる」「でる」<br>「ておく」「でおく」→「とく」「どく」　（といて、どいて）<br>「てしまう」「でしまう」→「ちゃう」「じゃう」（ちゃって、じゃって）<br>「ては」「では」→「ちゃ」「じゃ」<br>「なければ」→「なきゃ」<br>「っけ」用于确认不太明白的事情或者是问过却已经忘了的事情。</p><blockquote><p><strong>クリーニング屋、何時までだっけ。</strong></p></blockquote><p>「たりして」表示可能，也许，和「かもしれない」是同义词。<br>「たって」表示转折，前面接动词た形、<strong>くた</strong>或者だ。</p><blockquote><p>悲しくたって、サビシックたって、絶対泣かない。</p></blockquote><h1 id="「と」「なら」「たら」「ば」"><a href="#「と」「なら」「たら」「ば」" class="headerlink" title="「と」「なら」「たら」「ば」"></a>「と」「なら」「たら」「ば」</h1><h2 id="「と」的用法"><a href="#「と」的用法" class="headerlink" title="「と」的用法"></a>「と」的用法</h2><ul><li>恒常定理或者反复发生的事情。</li></ul><blockquote><p>このバタンを押すと、電気をつけるよ。</p></blockquote><ul><li>注意到了过去没有注意的事情，常带有意料之外的含义。</li></ul><blockquote><p> 気をつくと、外はすっかり暗くなっていた。</p></blockquote><h2 id="「たら」的用法"><a href="#「たら」的用法" class="headerlink" title="「たら」的用法"></a>「たら」的用法</h2><ul><li>注意到了过去没有注意的事情，常带有意料之外的含义。</li></ul><blockquote><p>発車のベルが鳴っているので飛び乗ったら、反対方向の電車だった。</p></blockquote><h2 id="「なら」的用法"><a href="#「なら」的用法" class="headerlink" title="「なら」的用法"></a>「なら」的用法</h2><ul><li>用于限定范围，提出建议或者要求。</li></ul><blockquote><p>上海に旅行に行くなら、１１月がいちばんいいと思います。</p></blockquote><ul><li>「ようなら・ようだったら・ようでしたら」<br>表示“要是。。。的话”，带有先看看，到时候再说的意思。</li></ul><blockquote><p>熱が下がらない要だったら病院に行ったほうがいいですよ。<br>特にご意見がないようでしたら、今日の会議はこれで終了いたします。</p></blockquote><p>在前面加上否定的时候，还能表示更加礼貌。</p><h2 id="用法区别"><a href="#用法区别" class="headerlink" title="用法区别"></a>用法区别</h2><div class="table-container"><table><thead><tr><th></th><th>たら</th><th>と</th><th>ば</th><th>なら</th></tr></thead><tbody><tr><td>口语</td><td>〇</td><td>〇</td><td>〇</td><td>〇</td></tr><tr><td>书面</td><td>-</td><td>〇</td><td>〇</td><td>〇</td></tr><tr><td>时间先后顺序</td><td>〇</td><td>〇</td><td>〇</td><td>-</td></tr><tr><td>后句使用意志</td><td>〇</td><td>-</td><td>*</td><td>〇</td></tr><tr><td>了，之后</td><td>〇</td><td>-</td><td>-</td><td>-</td></tr><tr><td>表示发现</td><td>〇</td><td>〇</td><td>-</td><td>-</td></tr><tr><td>提建议</td><td>-</td><td>-</td><td>-</td><td>〇</td></tr></tbody></table></div><h1 id="意志形"><a href="#意志形" class="headerlink" title="意志形"></a>意志形</h1><h2 id="「ようとする・ようとしない」"><a href="#「ようとする・ようとしない」" class="headerlink" title="「ようとする・ようとしない」"></a>「ようとする・ようとしない」</h2><p>表示现在开始要做某事，努力做某事，也可以表示要做某事的时候发生了意想不到的事情。否定有指责对方不做某事的责怪之意。</p><blockquote><p>小さい子供が道を渡ろうとしているよ。　（开始做某事）<br>昔の友達の名前を思い出そうとしたが、どうしても思い出せない。　（努力做某事）。<br>出かけようとしたら雨が降ってきた。　（意想不到的事情）<br>試験が近いのに、全然勉強しようとしない。　（责怪不做某事）</p></blockquote><h1 id="假定形"><a href="#假定形" class="headerlink" title="假定形"></a>假定形</h1><h2 id="「ばよかった」"><a href="#「ばよかった」" class="headerlink" title="「ばよかった」"></a>「ばよかった」</h2><p>表示因为自己没有做某事导致某个结果之后自己后悔。接续的时候如果前面是名词或二类形容词则使用「なら（ば）」。</p><blockquote><p>富士山は綺麗だね。カメラを持ってくればよかったね。</p></blockquote><h2 id="「ばいいのに」"><a href="#「ばいいのに」" class="headerlink" title="「ばいいのに」"></a>「ばいいのに」</h2><p>表示说话人对现在情况的不满，也可以对别人表示强烈的建议（否定其人现在的选择）。”明明。。。就好啊”</p><blockquote><p>このカバン、多すぎるよ、半額ならいいのになあ。</p></blockquote><h2 id="「～ば〜ほど」"><a href="#「～ば〜ほど」" class="headerlink" title="「～ば〜ほど」"></a>「～ば〜ほど」</h2><p>表示越怎么样，两个地方要使用同一个词汇。接续的时候，如果是二类形容词则为「〜なら〜なほど」，如果接续名词的话，则用「＋であればあるほど」。</p><blockquote><p>まじめな政治家であればあるほど、理想と現実の違いに悩むことになる。</p></blockquote><h2 id="「てからでなければ・てからでないと」"><a href="#「てからでなければ・てからでないと」" class="headerlink" title="「てからでなければ・てからでないと」"></a>「てからでなければ・てからでないと」</h2><p>如果不做什么的话就不行。から提示动作的先后顺序。</p><blockquote><p>入金を確認してからでなければ、商品が発送できません。<br>インフルエンザが治ってからでなければ学校へ来てはいけません。</p></blockquote><h1 id="表原因"><a href="#表原因" class="headerlink" title="表原因"></a>表原因</h1><h2 id="「からこそ」"><a href="#「からこそ」" class="headerlink" title="「からこそ」"></a>「からこそ」</h2><p>强调重要的，特别的理由。</p><blockquote><p>いろいろな国の人たちと交流できたのは留学したからこそだと思います。</p></blockquote><h2 id="「からといって」"><a href="#「からといって」" class="headerlink" title="「からといって」"></a>「からといって」</h2><p>就凭/仅仅是因为前面的理由，也怎么样怎么样，后面常常跟否定，或者不好的肯定。</p><blockquote><p>買い物は計画的に、安いからといって、買いすぎないようにしましょう。<br>運動は必要ですか、だからといって、やりすぎてはいけません。</p></blockquote><h2 id="「による・によって」-1"><a href="#「による・によって」-1" class="headerlink" title="「による・によって」"></a>「による・によって」</h2><p>表原因。</p><h2 id="「ために」"><a href="#「ために」" class="headerlink" title="「ために」"></a>「ために」</h2><p>表原因。</p><h2 id="「おかげ」-1"><a href="#「おかげ」-1" class="headerlink" title="「おかげ」"></a>「おかげ」</h2><p>表原因，托什么的福，带有感激的意味。</p><h2 id="「せい」"><a href="#「せい」" class="headerlink" title="「せい」"></a>「せい」</h2><p>表述原因，常常指的是坏的原因，“都怪xxx”。「せいで」表示当你很确定一个原因，「せいか」表示当你不太确定，“是不是由于xxx”。</p><blockquote><p>舞台の本番前で、緊張しているせいか、すごく喉が乾く。</p><p>連日の暑さのせいで、庭の花が全部枯れてしまった。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;N3常用语法总结。&lt;/p&gt;
    
    </summary>
    
      <category term="语言" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="日语" scheme="http://yoursite.com/tags/%E6%97%A5%E8%AF%AD/"/>
    
      <category term="JLPT" scheme="http://yoursite.com/tags/JLPT/"/>
    
  </entry>
  
  <entry>
    <title>链表Linked List常用代码片段</title>
    <link href="http://yoursite.com/2021/05/05/08_linkedlist/"/>
    <id>http://yoursite.com/2021/05/05/08_linkedlist/</id>
    <published>2021-05-05T18:48:01.685Z</published>
    <updated>2021-05-06T00:52:15.281Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了面试中关于Linked List的一些常用代码片段。</p><a id="more"></a><p>关于单链表最基础的知识就不说了，链表中每一个Node都可以用以下的class表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class Node:</span><br><span class="line">self.__init__(self, val = <span class="number">-1</span>, next = <span class="literal">None</span>):</span><br><span class="line">self.val = val</span><br><span class="line">self.next = next</span><br></pre></td></tr></table></figure><p>在上算法课的时候可能还会更加完善的定义一个class单纯表示LinkedList，里面只有一个叫head的Node实例，但是在面试里为了简略没有这种必要。一般假设直接把链表头的Node作为一个input variable。</p><h1 id="Traverse-a-linked-list"><a href="#Traverse-a-linked-list" class="headerlink" title="Traverse a linked list"></a>Traverse a linked list</h1><p>链表的本质就是在上一个Node里存储下一个Node的地址，以便于我们可以遍历整个链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse_linked_list</span><span class="params">(head)</span>:</span></span><br><span class="line">curr = head  <span class="comment">#指针</span></span><br><span class="line">  <span class="keyword">while</span> curr:  <span class="comment">#当指针没有指到末尾</span></span><br><span class="line">    <span class="comment"># 访问当前Node</span></span><br><span class="line">    curr = curr.next  <span class="comment">#指针指向下一个Node</span></span><br></pre></td></tr></table></figure><p>如果最后需要复制一份当前的linked list，或者根据当前链表返回一个新的链表（比如说Leetcode#2），为了简便，我们常常先规定一个dummy node作为开头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_a_copied_list</span><span class="params">(head)</span>:</span></span><br><span class="line">  <span class="comment">#dummy是最后要返回的链表头，curr是旧链表当前的位置，curr_new是返回链表的尾部</span></span><br><span class="line">  curr = head</span><br><span class="line">  dummy = Node()</span><br><span class="line">  curr_new = dummy</span><br><span class="line">  <span class="keyword">while</span> curr:</span><br><span class="line">    curr_new.next = Node(curr.val)</span><br><span class="line">    curr_new = curr_new.next</span><br><span class="line">    curr = curr.next</span><br><span class="line">  <span class="keyword">return</span> dummy.next <span class="comment">#最后返回的时候需要删除最开始的dummy node</span></span><br></pre></td></tr></table></figure><p>你当然可以直接更新head成head.next，但我们就无法再追踪到输入链表的头部了。</p><h1 id="Reverse-a-linked-list"><a href="#Reverse-a-linked-list" class="headerlink" title="Reverse a linked list"></a>Reverse a linked list</h1><p>很多题目里需要把一个linked list倒过来，这种需求的话因为我们还是只能从头访问链表，如果需要in place变换的话， 只需要一前一后两个指针，后指针是还没有变换过的剩余链表的头，前指针是反链表的尾部，在当前轮次，我们需要将后指针的next指向反链表的尾部，再更新前后指针，举一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1-&gt;2-&gt;3-&gt;4</span></span><br><span class="line"><span class="comment"># None&lt;-1 2-&gt;3-&gt;4 (prev:1, curr = 2)</span></span><br><span class="line"><span class="comment"># None&lt;-1&lt;-2 3-&gt;4 (prev:2, curr = 3)</span></span><br><span class="line"><span class="comment"># None&lt;-1&lt;-2&lt;-3 4 (prev:3, curr = 4)</span></span><br><span class="line"><span class="comment"># None&lt;-1&lt;-2&lt;-3&lt;-4 (prev:4, curr = None) end</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_in_place</span><span class="params">(head)</span>:</span></span><br><span class="line">prev, curr = <span class="literal">None</span>, head</span><br><span class="line">  <span class="keyword">while</span> curr:</span><br><span class="line">    tmp = curr.next <span class="comment">#记录curr.next因为马上我们要把curr.next指向prev了</span></span><br><span class="line">    curr.next, prev, curr = prev, curr, tmp</span><br><span class="line">  <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><p>如果你需要边reverse边构建一个新的linkedlist，那么prev指针永远指向新链表的头，curr只起到一个遍历旧链表的作用，代码可以改成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(head)</span>:</span></span><br><span class="line">  prev, curr = <span class="literal">None</span>, head</span><br><span class="line">  <span class="keyword">while</span> curr:</span><br><span class="line">    tmp = Node(curr.val)</span><br><span class="line">    tmp.next, prev = prev, tmp</span><br><span class="line">    curr = curr.next</span><br><span class="line">  <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><h1 id="Slow-and-fast-pointers"><a href="#Slow-and-fast-pointers" class="headerlink" title="Slow and fast pointers"></a>Slow and fast pointers</h1><p>快慢指针指的是两个指针从相同的起点一起开始跑，快指针每次跑两格，慢指针每次跑一格。这样当快指针跑到链表末尾的时候，慢指针正好处于链表的中间点。这种方法常常用来将链表等分为两份。按照需求，也可以有第三个指针slow_prev每次都更新为slow的前面一个Node，然后在最后的时候设置其next为None，这样就可以把链表分为两个子链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_linked_list</span><span class="params">(head)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="comment">#链表长度为0或1时</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">  slow, fast, slow_prev = head, head, <span class="literal">None</span></span><br><span class="line">  <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">    fast, slow_prev, slow = fast.next.next, slow, slow.next</span><br><span class="line">  slow_prev.next = <span class="literal">None</span>  <span class="comment">#这里slow_prev不可能为None，故为安全的访问</span></span><br><span class="line">  <span class="keyword">return</span> [head, slow] <span class="comment">#return two sub linked list</span></span><br></pre></td></tr></table></figure><p>将快慢指针都初始化为head的话，slow指针最后要么指向最中间的元素（奇数个Node情况下），要么指向后部第一个元素（偶数个Node的情况下）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1,2,3,4,5,6</span></span><br><span class="line"><span class="comment"># slow,fast = 1,1 -&gt; 2,3 -&gt; 3,5 -&gt; 4,None   slow = 4</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1,2,3,4,5,6,7</span></span><br><span class="line"><span class="comment"># slow,fast = 1,1 -&gt; 2,3 -&gt; 3,5 -&gt; 4,7  slow = 4</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了面试中关于Linked List的一些常用代码片段。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>古日语文法（2）- 动词活用及接续</title>
    <link href="http://yoursite.com/2021/04/21/07/"/>
    <id>http://yoursite.com/2021/04/21/07/</id>
    <published>2021-04-21T07:41:52.683Z</published>
    <updated>2021-04-21T09:41:32.249Z</updated>
    
    <content type="html"><![CDATA[<p>动词活用很好玩很有意思就是了。</p><a id="more"></a><p>日语中的活用（かつよう）指的是对用言和助动词进行的词形变化，以适应于不同的语气及语义，也可以说成日语中的变位。用言指的是动词，形容词和形容动词。</p><p>这里提一句动词/形容词/形容动词均属于自立语。自立语指的是可以直接使用，具有实义的词汇种类。除了该三类外还有不能活用的名词，副词，连体词，接续词和感动词。与自立语相对立的则是附属语，附属语中能够活用的是助动词，不能活用的是助词。</p><p>这篇文章主要先介绍动词的活用。用现在的语法举个简单的例子，比如「読む」，它在接「ます」的时候会变成「読み」，接「ない」的时候会变成「読ま」，接「ば」的时候会变成「読め」。</p><p>如果大家使用市面上普遍的日语教材的话，动词活用应该会根据一类动词，二类动词和三类动词介绍他们不同的活用方式。日本的教育文法则是把动词分为五段活用，上一段活用，下一段活用，カ行活用和サ行活用，分别对应一类，二类，来る和以する为后缀的三类动词。</p><p>古日语中则将动词分为九类，其中四段活用，上一段活用，上二段活用，下一段活用和下二段活用统称为正格活用；而其余四类 - カ行変格活用、サ行変格活用、ラ行変格活用和ナ行変格活用则统称为变格活用。</p><h1 id="活用种类"><a href="#活用种类" class="headerlink" title="活用种类"></a>活用种类</h1><p>再介绍九类动词的活用之前，先来看看有哪些活用的种类。 正如上文用「読む」举的例子所言，不同的接续涉及到的活用是不同的。日语中共有六类活用。</p><h2 id="未然形"><a href="#未然形" class="headerlink" title="未然形"></a>未然形</h2><p>表示还没有发生，还未这样的语气。否定的时候会用到这种活用，古语中表示推量“好像”的时候会用到，表示被动，使役的时候也会用到。类似于现代日语里所谓的「ない」形。</p><h2 id="连用形"><a href="#连用形" class="headerlink" title="连用形"></a>连用形</h2><p>表示中顿，名词化，接其他用言，接一些助动词的时候。类似于现代日语里所谓的「ます」形，「て」形和「た」形。</p><h2 id="终止形"><a href="#终止形" class="headerlink" title="终止形"></a>终止形</h2><p>后面不接续任何东西，或者只接续终助词（语气助词）的时候使用。类似于现代日语里的动词现在肯定简体形。</p><h2 id="连体形"><a href="#连体形" class="headerlink" title="连体形"></a>连体形</h2><p>后接续体言，也即是名词的形式。现代日语里连体形和终止形已经几乎是统一了，你可以说「君に<strong>会う</strong>」，也可以用同样的形式说「君と<strong>会う</strong>場合」。但在古日语中他们常常是不一样的。</p><h2 id="已然形"><a href="#已然形" class="headerlink" title="已然形"></a>已然形</h2><p>也叫做假定形。现代日语里可以接「ば」表示假定条件，古日语里常用于表示原因和理由（假定条件不用此形式）。</p><h2 id="命令形"><a href="#命令形" class="headerlink" title="命令形"></a>命令形</h2><p>和终止形一样，后面不接任何东西，或者只接终助词，但用于表示命令的形式。</p><h1 id="正格活用"><a href="#正格活用" class="headerlink" title="正格活用"></a>正格活用</h1><h2 id="四段活用"><a href="#四段活用" class="headerlink" title="四段活用"></a>四段活用</h2><p>以「笑む」（えむ）举例。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>笑<strong>ま</strong></td><td>笑<strong>み</strong></td><td>笑<strong>む</strong></td><td>笑<strong>む</strong></td><td>笑<strong>め</strong></td><td>笑<strong>め</strong></td></tr></tbody></table></div><p>简单来记的话可以去掉词干把变形部分记成「ア・イ・ウ・ウ・エ・エ」。由于只涉及到a，i，u，e四段，故被称为四段活用。这类动词和现代日语里的一类动词大部分是重叠的。</p><h2 id="上一段活用"><a href="#上一段活用" class="headerlink" title="上一段活用"></a>上一段活用</h2><p>以「見る」举例。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>み</td><td>み</td><td>みる</td><td>みる</td><td>みれ</td><td>みよ</td></tr></tbody></table></div><p>简单记忆的话则是「イ・イ・イる・イる・イれ・イよ」。由于活用只涉及到i段（u段的上一段），故被称为上一段活用。这一类单词很好记，词尾る之前只有单个i段的音。常用的有：</p><ul><li>見る　みる</li><li>煮る　にる　</li><li>似る　にる</li><li>干る　ひる</li><li>着る　きる</li><li>射る　いる</li><li>鋳る　いる</li><li>居る　ゐる</li><li>率る　ゐる</li></ul><h2 id="下一段活用"><a href="#下一段活用" class="headerlink" title="下一段活用"></a>下一段活用</h2><p>常用的只有「蹴る」（ける）这一个单词。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>け</td><td>け</td><td>ける</td><td>ける</td><td>けれ</td><td>けよ</td></tr></tbody></table></div><p>简单记忆的话则是「ケ・ケ・ケる・ケる・ケれ・ケよ」。由于活用只涉及到e段（u段的下一段），故被称为下一段活用。</p><h2 id="上二段活用"><a href="#上二段活用" class="headerlink" title="上二段活用"></a>上二段活用</h2><p>以「過ぐ」举例。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>過ぎ</td><td>過ぎ</td><td>過ぐ</td><td>過ぐる</td><td>過ぐれ</td><td>過ぎよ</td></tr></tbody></table></div><p>记忆的时候则是可以简单记成「イ・イ・ウ・ウる・ウれ・イよ」。由于涉及到了i段和u段，故被称为上二段活用。</p><h2 id="下二段活用"><a href="#下二段活用" class="headerlink" title="下二段活用"></a>下二段活用</h2><p>以「受く」举例。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>受け</td><td>受け</td><td>受く</td><td>受くる</td><td>受くれ</td><td>受けよ</td></tr></tbody></table></div><p>记忆的时候则是可以简单记成「ケ・ケ・ウ・ウる・ウれ・ケよ」。由于涉及到了e段和u段，故被称为下二段活用。</p><h1 id="变格活用"><a href="#变格活用" class="headerlink" title="变格活用"></a>变格活用</h1><h2 id="カ行变格活用"><a href="#カ行变格活用" class="headerlink" title="カ行变格活用"></a>カ行变格活用</h2><p>一般指的是「来る」这个动词的活用。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>こ</td><td>き</td><td>く</td><td>くる</td><td>くれ</td><td>こ（よ）</td></tr></tbody></table></div><p>和现代日语的差别主要在于终止形只用く而不用くる，还有命令形也并不是こい而是こ或者こよ。</p><h2 id="サ行变格活用"><a href="#サ行变格活用" class="headerlink" title="サ行变格活用"></a>サ行变格活用</h2><p>典型的有「する」和「おはす」这两个动词。「おはす」为「いらっしゃる」的古语。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>せ</td><td>し</td><td>す</td><td>する</td><td>すれ</td><td>せよ</td></tr></tbody></table></div><h2 id="ナ行变格活用"><a href="#ナ行变格活用" class="headerlink" title="ナ行变格活用"></a>ナ行变格活用</h2><p>典型的有「死ぬ」和「往ぬ・去ぬ」。以「往ぬ」举例。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>往な</td><td>往に</td><td>往ぬ</td><td>往ぬる</td><td>往ぬれ</td><td>往ね</td></tr></tbody></table></div><h2 id="ラ行变格活用"><a href="#ラ行变格活用" class="headerlink" title="ラ行变格活用"></a>ラ行变格活用</h2><p>典型的有「あり」、「をり」、「はべり」、「いまそかり」等。以「あり」举例。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>あら</td><td>あり</td><td>あり</td><td>ある</td><td>あれ</td><td>あれ</td></tr></tbody></table></div><p>这个变格活用和四段活用的唯一差别是终止形和连用形同形而不是和连体形同形。</p><h1 id="特殊注意点"><a href="#特殊注意点" class="headerlink" title="特殊注意点"></a>特殊注意点</h1><h2 id="同一个动词古今分类不同"><a href="#同一个动词古今分类不同" class="headerlink" title="同一个动词古今分类不同"></a>同一个动词古今分类不同</h2><p>比如说「借りる」这个单词，现代日语中他是上一段活用，表否定的时候用未然形加上打消助动词「ない」或者「ず」，现代日语中应该是「借りない」。而古日语中，「借る」是一个四段活用动词，表否定的时候应该为「借らず」。</p><p>同样的还有「足る」「飽く」在古语中均为四段活用，而在现代日语中均为一段活用。「恨む」在古日语中为上二段活用，而在现代日语中为五段活用。</p><h2 id="容易与「ア行」搞混的变形部分"><a href="#容易与「ア行」搞混的变形部分" class="headerlink" title="容易与「ア行」搞混的变形部分"></a>容易与「ア行」搞混的变形部分</h2><p>「老ゆ」（おゆ）、「悔ゆ」（くゆ）、「報ゆ」（むくゆ）均为ヤ行上二段动词，虽然他们的未然形是以「い」结尾的，但他们不是「ア行」的活用。</p><p>「覚ゆ」（おぼゆ）、「燃ゆ」（もゆ）、「絶ゆ」（たゆ）、「見ゆ」（みゆ）均为ヤ行下二段动词，虽然他们的未然形是以「え」结尾的，但他们不是「ア行」的活用。</p><p>「植う」（うう）、「飢う」（うう）、「据う」（すう）均为ワ行下二段动词，虽然他们的终止形都是以「う」结尾的，但「植う」的未然形是「植ゑ」而不是「植え」。</p><h2 id="终止形只有一个假名的动词"><a href="#终止形只有一个假名的动词" class="headerlink" title="终止形只有一个假名的动词"></a>终止形只有一个假名的动词</h2><p>「得」（う）、「経」（ふ）、「寝」（ね）他们都是下二段动词。比如「得」，他的活用形则为「得（え）・得（え）・得（う）・得る（うる）・得れ（うれ）・得よ（えよ）」。</p><h2 id="具有两种活用的动词"><a href="#具有两种活用的动词" class="headerlink" title="具有两种活用的动词"></a>具有两种活用的动词</h2><p>「頼む」、「被く」（かづく）、「漬つ」（ひつ）都有四段和下二段两种活用方法，他们的区别是一个为他动词，一个为自动词。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动词活用很好玩很有意思就是了。&lt;/p&gt;
    
    </summary>
    
      <category term="语言" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="日语" scheme="http://yoursite.com/tags/%E6%97%A5%E8%AF%AD/"/>
    
      <category term="语法" scheme="http://yoursite.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>古日语文法（1）- 五十音图和古语假名遣</title>
    <link href="http://yoursite.com/2021/04/11/06/"/>
    <id>http://yoursite.com/2021/04/11/06/</id>
    <published>2021-04-11T07:09:26.185Z</published>
    <updated>2021-04-11T08:27:54.357Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习N3的道路上偶尔开始接触比较深奥/古早的语法，然后思绪就开始从原来的仅追求知其然变成了想知其所以然。又偶然看到了一些关于语源和文法分析的文章，所以打算入门一下古日语 —— 其中的一部分对理解现代日语是很有帮助的。</p><a id="more"></a><h1 id="五十音图"><a href="#五十音图" class="headerlink" title="五十音图"></a>五十音图</h1><p>在入门现代日语的时候，大部分人接触的第一道门槛就是记忆五十音图。说是五十音图，其实不如说是46音图。除了「ア行」、「カ行」、「サ行」、「タ行」、「ナ行」、「ハ行」、「マ行」、「ラ行」的八行是完整的之外，「ヤ行」只保留了「や・ゆ・よ」，「ワ行」只保留了「わ・を」，再另外加上一个拨音「ん」。</p><p>而在古语中，五十音图确确实实是五十个音。在其余八行仍为完整的情况下，「ヤ行」和「ワ行」也是完整的。</p><div class="table-container"><table><thead><tr><th></th><th>ア段</th><th>イ段</th><th>ウ段</th><th>エ段</th><th>オ段</th></tr></thead><tbody><tr><td>ヤ行</td><td>や　ya</td><td><strong>い</strong>　i</td><td>ゆ　yu</td><td><strong>え</strong>　e</td><td>よ　yo</td></tr><tr><td>ワ行</td><td>わ　wa</td><td><strong>ゐ</strong>　i</td><td><strong>う</strong>　u</td><td><strong>ゑ</strong>　e</td><td>を　wo</td></tr></tbody></table></div><h1 id="假名遣"><a href="#假名遣" class="headerlink" title="假名遣"></a>假名遣</h1><h2 id="「ハ行」的读音"><a href="#「ハ行」的读音" class="headerlink" title="「ハ行」的读音"></a>「ハ行」的读音</h2><p>古语中 「ハ行」的读音一般为「ワ行」，这也是为什么提示助词は（表主题）直到如今还在念wa的原因。</p><blockquote><p><strong>いはひ</strong>　→  祝い</p><p><strong>いへ</strong>　→  家</p><p><strong>いふ</strong>　→  言う</p></blockquote><p>但是当「ハ行」位于语头的时候，不变音。</p><blockquote><p><strong>はな</strong>　→  花</p></blockquote><h2 id="双重母音的连读"><a href="#双重母音的连读" class="headerlink" title="双重母音的连读"></a>双重母音的连读</h2><p>当有两个母音连在一起的时候，为了发音方便，会产生音变。具体为：</p><ul><li>あう　au →　おう ō</li><li>いう　iu →　ゆう yū</li><li>えう　eu →　よう yō</li><li>おう　ou →　おう ō</li></ul><blockquote><p><strong>あうむ</strong>　→　鸚鵡(おうむ）</p><p><strong>いうなり</strong>　→　優なり(ゆうなり）</p><p><strong>えうじ</strong>　→　用事(ようじ）</p><p><strong>おうな</strong>　→　嫗(おうな）</p></blockquote><h2 id="以直音表拗音"><a href="#以直音表拗音" class="headerlink" title="以直音表拗音"></a>以直音表拗音</h2><p>古语中有些情况下，假名的普通组合能音变成拗音。以两个例子来说明：</p><blockquote><p><strong>てふ</strong>　→　てう　t[eu] →  　t[yō] 　→　ちょう　蝶</p><p><strong>けふ</strong>　→　けう　k[eu] →  　k[yō] 　→　きょう　今日</p></blockquote><p>以上的例子结合了ha的wa音变和双重母音的连读。</p><h2 id="「ゐ、ゑ、を」的读音"><a href="#「ゐ、ゑ、を」的读音" class="headerlink" title="「ゐ、ゑ、を」的读音"></a>「ゐ、ゑ、を」的读音</h2><p>他们的读音即为i，e，o。</p><blockquote><p><strong>居る（ゐる）</strong>　→　いる</p><p><strong>声（こゑ）</strong>　→　こえ</p><p><strong>折（をり）</strong>　→　おり</p></blockquote><h2 id="「む」的读音"><a href="#「む」的读音" class="headerlink" title="「む」的读音"></a>「む」的读音</h2><p>在单词中间的「む」，助动词「む・らむ」，助词「なむ」中的「む」都读成拨音「ん」。</p><blockquote><p> <strong>東（ひむがし）</strong>　→　ひんがし</p><p><strong>行くらむ（いくらむ）</strong>　→　行くらん</p></blockquote><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>结合以上五个常用的古语假名遣，严格意义上无论古语中的词汇是怎么写的，都能念出他们的正确读音。以下左边是古语中一些词汇的假名标法，将他们翻译之后发现读法和现代相差无几。所以一般，无论古语里的假名注音写的多么fancy，读法还是会和现代日语很相似。</p><blockquote><p><strong>匂ひ（にほひ）</strong>　→　匂い（におい）</p><p><strong>田舎（ゐなか）</strong>　→　田舎（いなか）</p><p><strong>酔ふ（ゑふ）</strong>　→　酔う（よう）</p><p><strong>荻（をぎ）</strong>　→　荻（おぎ）</p><p><strong>扇（あふぎ）</strong>　→　扇（おうぎ）</p><p><strong>追ふ（おふ）</strong>　→　追う（おう）</p><p><strong>手水（てうづ）</strong>　→　手水（ちょうず）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习N3的道路上偶尔开始接触比较深奥/古早的语法，然后思绪就开始从原来的仅追求知其然变成了想知其所以然。又偶然看到了一些关于语源和文法分析的文章，所以打算入门一下古日语 —— 其中的一部分对理解现代日语是很有帮助的。&lt;/p&gt;
    
    </summary>
    
      <category term="语言" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="日语" scheme="http://yoursite.com/tags/%E6%97%A5%E8%AF%AD/"/>
    
      <category term="语法" scheme="http://yoursite.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>以「通」为语干的日语动词辨析</title>
    <link href="http://yoursite.com/2021/03/30/05%E9%80%9A%E5%92%8C%E9%80%83%E7%9A%84%E8%BE%A8%E6%9E%90/"/>
    <id>http://yoursite.com/2021/03/30/05通和逃的辨析/</id>
    <published>2021-03-30T08:06:12.711Z</published>
    <updated>2021-03-31T04:13:40.442Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结了相同语干的动词的不同训读和用法区别。<br><a id="more"></a></p><h3 id="通"><a href="#通" class="headerlink" title="通"></a>通</h3><p>以通为词干的日语常用动词有以下四个：</p><blockquote><p>　通う  　かよう</p><p>　通る  　とおる</p><p>　通じる  　つうじる</p><p>　通す  　とおす</p></blockquote><p>首先通う表示定期的往返，也有自由来去，到处走来走去的意思，此时意思有点像「流れる」。也可以表示连通、此时意思和通じる一致。</p><blockquote><p>　学校に通う/会社に通う   （定期往返）</p><p>　血が体に通う  （自由来去）</p><p>　江戸へ通う街道   （连接性）</p></blockquote><p>通じる即是自动词，也是他动词，主要表示的是连通性，此时强调到达目的地是有可能的，能达到的。古语写成通ずる。</p><blockquote><p>電話が通じる </p><p>都市へ通じる道</p><p>内部の事情に通じる</p></blockquote><p>通る和通す的意思几乎一致，区别在于通る为自动词，而通す为他动词。他们都是通过，经过的意思。</p><blockquote><p>たくさんの人がぞろぞろ透る</p><p>銅線に電流を通す</p></blockquote><p>由于他们两者还能写成透る和透す，所以还能表示光线等透过。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结了相同语干的动词的不同训读和用法区别。&lt;br&gt;
    
    </summary>
    
      <category term="语言" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="日语" scheme="http://yoursite.com/tags/%E6%97%A5%E8%AF%AD/"/>
    
      <category term="语法" scheme="http://yoursite.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>否定助动词「ず」与「ぬ」的用法解说</title>
    <link href="http://yoursite.com/2021/03/15/04_zu_to_nu/"/>
    <id>http://yoursite.com/2021/03/15/04_zu_to_nu/</id>
    <published>2021-03-15T09:05:00.000Z</published>
    <updated>2021-04-02T06:43:15.661Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结了古日语和现代日语中否定助动词「ず」和「ぬ」的活用以及文法区别。<br><a id="more"></a> </p><h3 id="古日语中的否定助动词「ず」"><a href="#古日语中的否定助动词「ず」" class="headerlink" title="古日语中的否定助动词「ず」"></a>古日语中的否定助动词「ず」</h3><p>现代日本语中对一个动词进行否定一般为动词未然形加上否定助动词（打ち消しの助動詞）「ない」构成，比如</p><blockquote><p><strong>飲まない</strong><br><strong>食べない</strong><br><strong>しない</strong></p></blockquote><p>在古日语中，否定助动词「ず」与上文所提到的「ない」具有相同的作用，即加于动词未然形之后对某个动词进行否定。</p><blockquote><p><strong>飲まず</strong><br><strong>食べず</strong><br><strong>せず</strong>  （せ是古日语中サ行活用的未然形）</p></blockquote><p>与现代日语中「ないで」类似，古语中「ずに」作为连用修饰语表达“在～的状态下怎样怎样”，体会接下来两个句子：</p><blockquote><p><strong>何も言わずに去っていた</strong> （什么也不说，就走了）<br><strong>飲まず食わず働いてる</strong> （不吃不喝在工作）</p></blockquote><p>接下来将要提到的是「ず」的活用。</p><h4 id="连用形「ず」"><a href="#连用形「ず」" class="headerlink" title="连用形「ず」"></a>连用形「ず」</h4><blockquote><p><strong>家族に会えず、寂しいです。</strong></p></blockquote><h4 id="终止形「ず」"><a href="#终止形「ず」" class="headerlink" title="终止形「ず」"></a>终止形「ず」</h4><blockquote><p><strong>あの奴は本当に恩知らず。</strong> (那个家伙真的不知恩图报）</p></blockquote><h4 id="连体形「ぬ」"><a href="#连体形「ぬ」" class="headerlink" title="连体形「ぬ」"></a>连体形「ぬ」</h4><p>这里就说到了比如容易混淆的一点：日语中ぬ是ず的连体形，也即ず是无法直接修饰体言的（名词，数词，代词），ぬ才可以。</p><blockquote><p><strong>触らぬ神に祟りなし。</strong> （多一事不如少一事）</p></blockquote><p>其他的一些ず的活用总结在下表，注意第二行的活用又被称为辅助活用，既可以单独使用也可以在其后加一些其他的助动词一起使用。</p><div class="table-container"><table><thead><tr><th>未然形</th><th>连用形</th><th>终止形</th><th>连体形</th><th>已然形</th><th>命令形</th></tr></thead><tbody><tr><td>ず</td><td>ず</td><td>ず　</td><td>ぬ</td><td>ね　</td><td>ざり</td></tr><tr><td>ざら</td><td>ざり　</td><td>ず　</td><td>ざる</td><td>ざれ</td><td>ざり</td></tr></tbody></table></div><p>比如</p><blockquote><p><strong>選ばれざる国民</strong>　（不被选择的国民）</p></blockquote><h3 id="现代日语中否定助动词「ぬ」的延伸用法"><a href="#现代日语中否定助动词「ぬ」的延伸用法" class="headerlink" title="现代日语中否定助动词「ぬ」的延伸用法"></a>现代日语中否定助动词「ぬ」的延伸用法</h3><p>在现代日语中，ぬ除了用作否定助动词的连体形之外，还可以用作终止形。并且无论是连体形还是终止形的时候都可以与ん互换。例如，</p><blockquote><p><strong> 知らぬ。</strong><br><strong>分からん。</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结了古日语和现代日语中否定助动词「ず」和「ぬ」的活用以及文法区别。&lt;br&gt;
    
    </summary>
    
      <category term="语言" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="日语" scheme="http://yoursite.com/tags/%E6%97%A5%E8%AF%AD/"/>
    
      <category term="语法" scheme="http://yoursite.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="古日语" scheme="http://yoursite.com/tags/%E5%8F%A4%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>OPERATING SYSTEM - PROCESS 进程</title>
    <link href="http://yoursite.com/2019/01/11/03-osprocess/"/>
    <id>http://yoursite.com/2019/01/11/03-osprocess/</id>
    <published>2019-01-12T06:04:18.000Z</published>
    <updated>2019-06-19T04:46:52.611Z</updated>
    
    <content type="html"><![CDATA[<p>最近节日大爆发，感恩节接着圣诞节，再接着元旦，除了跨年外实在是没有事情做，索性就学习好了。操作系统是一直以来想看的内容，自从大三的时候操作系统课拿了个D，就一直想什么时候重新学一下。好吧那就不要拖延的看起来吧。选择的课本是Abraham Silberschatz的经典之作“Operating System Concepts (10th Edition)”。本篇学习笔记出自于这本书的第三章“Process”。如果有什么地方理解不到位，或者写的不清楚欢迎留言指出，一起进步。<br><a id="more"></a> </p><h3 id="什么是Process？"><a href="#什么是Process？" class="headerlink" title="什么是Process？"></a>什么是Process？</h3><p>一个Process一般代表计算机的一项任务或一项活动，它并不是程序本身，而是程序加上程序现在处于的状态。一个process的memory可以分成以下几个section：</p><ul><li>Text表示一些固定长度的只读文本。</li><li>Data分为初始化的data和未初始化的data（bss），比如在C里的 $int$ $a = 3;$和$int$ $a;$。</li><li>Heap和stack都是flexible length的，如图所示heap是向高地址扩展的，而stack是向低地址扩展的。当你动态allocate一些memory的时候，其实获取的是heap的memory，在C里就是malloc函数族。</li><li>Stack的作用是存储一些临时变量，比如在调用一个函数的时候，输入，本地变量，还有返回地址会被push到stack上，直到函数调用完成后这一个block才被pop出来。</li></ul><p>当然heap和stack有可能会无止境增长直到重叠，在现在操作系统里一般都会有机制防止这种情况发生。在stack即将和heap重叠的时候可能会报stack overflow的错。在heap空间不够的时候malloc会直接返回NULL告诉你heap空间不够了。</p><p>这里的重点是，程序不是process。如果一个程序需要完成多项工作，它可以produce很多进程。</p><h3 id="Process的状态"><a href="#Process的状态" class="headerlink" title="Process的状态"></a>Process的状态</h3><ul><li>New Process刚被创建</li><li>Ready Process正在等待被分配运行（通常有一个scheduler来分配）</li><li>Running Process正在被执行</li><li>Waiting 相当于暂停，进程等待某个事件的发生（可能是某种signal，或者是OS把运行权限交回给这个process）</li><li>Terminated Process完成工作，等待OS回收<br>一般，处理器有几个core，就能真正同时运行几个process。比如6-core的处理器能真正同时处理6个process。在每个process core里，还能够伪同步地处理多个process，这是因为OS的scheduler会不停的context switch，在多个process中切换，造成多个process同时运行的假象。</li></ul><h3 id="Process-Control-Block"><a href="#Process-Control-Block" class="headerlink" title="Process Control Block"></a>Process Control Block</h3><p>这是一个拥有process各种metadata的字节块。它包括：</p><ul><li>Process State</li><li>Program Counter 这个进程下一步需要执行的指令所在的位置，他会根据process的运行动态更新。</li><li>CPU Register 与这个process相关的寄存器里的值</li><li>CPU Schedueling Info, Memory Management Info, Stats, I/O Info 与这个process相关的Scheduler, Memory manager, 运行状态和I/O状态的信息<br>其实所有的内容还是为了当这个process重新运行的时候恢复到上次运行的状态而储存的。</li></ul><h3 id="Process调度"><a href="#Process调度" class="headerlink" title="Process调度"></a>Process调度</h3><p>为什么要做process的调度？因为process会因为各种原因运行很长的时间，比如需要计算很多东西（Computing Bound），或者需要做很多I/O工作（I/O Bound），或者在等子进程完成他们的任务。为了不浪费CPU的资源，processer需要在多个process之间进行切换，防止有空闲的时间。</p><p>一般来说，OS会维持两个queue。其中一个是ready queue，是一些运行的时候被interrupt的process，他们随时随地都能被re-run。还有一个是wait queue，他们是本身在等待某些signal的process。当它们收到signal之后，会被放进ready queue。</p><p>CPU Scheduler的任务是在ready queue里选出一个process，并把他assign给某个core去运行。为了保证某些空闲的process不占用CPU，scheduler会很频繁的运行，即使会打断一些在正常运行的process。打断进程和恢复进程是通过context switch进行的，简单来说就是先把当前process的所有状态存到它的PCB里去，然后再resume另一个进程的PCB。Context switch是一个很纯粹的overhead，他除了调度之外不做其他的事情，并且它的速度取决于硬件。</p><h3 id="创建一个Process"><a href="#创建一个Process" class="headerlink" title="创建一个Process"></a>创建一个Process</h3><p>一个Process是由其他的Process创建出来的，这个被创建的Process叫做子进程，它是由它的parent process创建出来的。在计算机boot的时候，OS会创建它的第一个process——init（pid=1）。它是所有进程的父进程。所以计算机里所有process的关系就组成了一个tree。每一个process会有自己的一个唯一的pid（process id）。</p><p>当进程创建自己的子进程的时候，子进程可以从OS那里拿到自己份的资源，也可以是从自己的父进程那里分一部分的资源。（这是OS层面的一个实现决策。）像后者的话可以防止一个进程创建出太多的子进程而占用太多资源。</p><p>当子进程被创建之后，它会复制一份父进程的地址空间。这里指的是两个进程的memory layout以及里面的数据是完全一样的，只是因为他们是虚拟地址空间，他们会指向实体memory里的不同位置。一般来说当子进程被创建后，它可以做和父进程完全一样的任务，或者可以做自己的新的任务。而父进程的话可以等待子进程的完成然后再terminate自己，或者也可以继续做事。</p><p>fork()函数是用来创建子进程的函数，它很神奇，在于它有两个返回值。由于调用fork之后子进程已经被创建了，这个函数的返回值其实是被两个进程可见的，但是它在两个进程的返回值是不一样的。它在子进程里返回0，在父进程里返回子进程的pid。</p><pre><code>int main() {      pid_t pid;    pid = fork();    if (pid &lt; 0) {        fprintf(stderr, &quot;Fork Failed&quot;);        return 1;    } else if (pid == 0) {        execlp(&quot;/bin/ls&quot;, &quot;ls&quot;, NULL);    } else {        wait(NULL);        printf(&quot;Child Process Complete.&quot;);    }    return 0;}</code></pre><p>先看一下上面这个例子，父进程调用fork之后，两个进程一起进入if判断。pid == 0的那个分支会被子进程执行，因为fork在子进程里返回值为0。这里子进程是直接执行了一个新的任务了。else的那个分支会被父进程执行，因为子进程的pid永远是一个正数，父进程的做法是挂停，并且等待子进程的完成（查看wait函数）。父进程会在子进程结束后收到signal，并且重新执行下去。再看一个例子：</p><pre><code>int main() {    fork();    fork();    fork();    return 0;}</code></pre><p>那么包含当前进程，现在一共有多少进程在run？ 答案是8个。</p><h3 id="结束一个Process"><a href="#结束一个Process" class="headerlink" title="结束一个Process"></a>结束一个Process</h3><p>当一个Process结束它的任务时，它通过调用exit函数实现system call，从而达成资源的回收。一个Process也可以被另一个Process所terminate，出于安全的考虑，一般只有它的父进程有这样的权限。父进程强行terminate它的子进程一般可以是因为，子进程占用了太多的资源，子进程的任务不再需要被完成了，或者父进程自己即将被terminate了。一般来说，父进程需要等其子进程都被terminate了，自己才能terminate。</p><p>如果父进程在子进程完成之前被terminate了，我们称子进程为orphan process。这种情况下，通常由init进程来通过wait函数把他kill掉。还有一个概念叫做zombie process。由于子进程结束的时候，它假设它的父进程还在运行中，并且最终会检查且kill掉自己。为了使父进程能够知道自己的状态，它必须还将自己的metadata维持在process table中。这样一个不再工作的，却等待父进程来kill掉自己的进程叫做zombie process。</p><h3 id="IPC-Interprocess-Communication-进程间通信"><a href="#IPC-Interprocess-Communication-进程间通信" class="headerlink" title="IPC - Interprocess Communication 进程间通信"></a>IPC - Interprocess Communication 进程间通信</h3><p>什么情况下需要IPC？比如需要同时（不出错的）访问某一块地址上的数据，比如需要一起完成某一项大任务。IPC能够允许两个进程之间交换数据，更具体地说，发送和接受消息。具体说来，IPC的实现主要有shared memory和message passing两种方法。</p><p>Shared memory主要通过建立一块两个进程的公共内存区域。这种方法会使IPC比较快速，但是增加了实现的难度。如果两个进程都同意他们即将共享某一个内存区域，他们就可以这么做，同时他们应该做好concurrency的管理工作。POXIS系统里提供了这种IPC方法的API。</p><p>Message passing主要指两个进程之间互相收发信息，这种方法一般比较好实现，也不需要做concurrency的管理，所以分布式系统比较会用这种方法。如果两个进程可以互相传送信息的话，逻辑层面上他们之间需要有一个link。关于这个link，设计的时候可以有以下的几种option：</p><p>Direct or Indirect 在每个process想和别的process进行通信的时候，需要严格说明对方的名称，或者只有sender需要说明对方的名称。这种精确到名字的link一般不太好使用，一旦process的id被update了，这种方法的overhead会非常高。Indirect的link的话，有port做过度。这样的话IPC就不是直接进程对进程，而是两组进程对port。port可以是OS层面的，也可以是进程层面的。<br>Synchronization or Asynchronization 是不是允许sender和receiver 被block？<br>Buffering 是不是允许sender和receiver有一个queue来存储一系列的消息？还是只能够一条一条的发送和接收？<br>Pipe是一种message passing的IPC方法。一个pipe有两端，每一端都是一个file descriptor，一端作为读口，一端作为写口。原始的pipe允许一个进程从其中一端写入，允许另一个进程从另外一端读取。一般来说，原始的pipe的使用场景在于父进程和子进程之间的IPC。首先，父进程创建一个新的pipe，然后调用fork函数创建子进程。这时父进程和子进程同时都有相同的pipe。之后分别关闭掉父进程和子进程中不用的一端，即可完成父进程和子进程之间的写入读取。当然pipe的设计可以有多种option，比如是不是只允许父子进程的通信，或者允许单方向还是双方向。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近节日大爆发，感恩节接着圣诞节，再接着元旦，除了跨年外实在是没有事情做，索性就学习好了。操作系统是一直以来想看的内容，自从大三的时候操作系统课拿了个D，就一直想什么时候重新学一下。好吧那就不要拖延的看起来吧。选择的课本是Abraham Silberschatz的经典之作“Operating System Concepts (10th Edition)”。本篇学习笔记出自于这本书的第三章“Process”。如果有什么地方理解不到位，或者写的不清楚欢迎留言指出，一起进步。&lt;br&gt;
    
    </summary>
    
      <category term="Geek" scheme="http://yoursite.com/categories/Geek/"/>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>日语中表示命令的几种用法区分</title>
    <link href="http://yoursite.com/2018/12/23/02-japcmd/"/>
    <id>http://yoursite.com/2018/12/23/02-japcmd/</id>
    <published>2018-12-24T05:40:03.000Z</published>
    <updated>2019-05-23T04:48:57.277Z</updated>
    
    <content type="html"><![CDATA[<p>标日初级下册的第29课「電気を消せ」中主要讲授了日语中表示命令的几种用法，他们在意思上都大同小异，主要都表示“快去做某事！”，或者“不准做某事！”。初学的时候没怎么在意，直到做了同步练习才发现自己什么都没搞清。。这篇日志主要对这几种用法做一些总结与区分。<br><a id="more"></a> </p><h4 id="直接使用动词的命令型"><a href="#直接使用动词的命令型" class="headerlink" title="直接使用动词的命令型"></a>直接使用动词的命令型</h4><p>命令型的活用规则不再赘述，命令型可以说是语气最强的命令形式，一般是有权力的一方对待没有权力的一方，或者是年长者对待年轻者身上。紧急情况下（比如要求对方注意安全）可以使用。此外，还可以在体育比赛中加油鼓劲或者是男性友人之间劝酒中使用。女性一般不使用这种形式。（以下所有的例子取自于标日同步练习）</p><ul><li>主任：おーい！鈴木！ちょうと来い！　-鈴木：はい、何ですか。　-主任：これを片付けろ！</li></ul><h4 id="使用「動詞＋な」表示禁止"><a href="#使用「動詞＋な」表示禁止" class="headerlink" title="使用「動詞＋な」表示禁止"></a>使用「動詞＋な」表示禁止</h4><p>语气最强表示禁止，或者否定的用法，意思是不要做某事，禁止做某事。</p><p>ここでタバコを吸うな！</p><h4 id="使用「動詞連用形＋なさい」"><a href="#使用「動詞連用形＋なさい」" class="headerlink" title="使用「動詞連用形＋なさい」"></a>使用「動詞連用形＋なさい」</h4><p>语气次强烈表示做某事的用法。可以用在老师对学生，父母对子女身上。常常也会在考试的题目说明中看到「答えなさい」的用法。</p><p>早く起きなさい。遅刻するわよ。</p><h4 id="使用「動詞て形・動詞ない形＋で」"><a href="#使用「動詞て形・動詞ない形＋で」" class="headerlink" title="使用「動詞て形・動詞ない形＋で」"></a>使用「動詞て形・動詞ない形＋で」</h4><p>语气最不强烈的祈使用法，男性女性都可以用，一般用在比较亲密的人身上。</p><p>静かにして。大きな声を出さないで。赤ちゃんが寝たから。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标日初级下册的第29课「電気を消せ」中主要讲授了日语中表示命令的几种用法，他们在意思上都大同小异，主要都表示“快去做某事！”，或者“不准做某事！”。初学的时候没怎么在意，直到做了同步练习才发现自己什么都没搞清。。这篇日志主要对这几种用法做一些总结与区分。&lt;br&gt;
    
    </summary>
    
      <category term="FineArts" scheme="http://yoursite.com/categories/FineArts/"/>
    
    
      <category term="Japanese" scheme="http://yoursite.com/tags/Japanese/"/>
    
  </entry>
  
  <entry>
    <title>CMU好课推荐：15-122 PRINCIPLES OF IMPERATIVE PROGRAMMING</title>
    <link href="http://yoursite.com/2018/10/04/01-cmu15122/"/>
    <id>http://yoursite.com/2018/10/04/01-cmu15122/</id>
    <published>2018-10-05T04:30:10.000Z</published>
    <updated>2019-05-23T04:49:18.789Z</updated>
    
    <content type="html"><![CDATA[<p>安然无恙（其实头发很有恙）的度过了在匹兹堡的第一个学期，能在五门课中活下来证明还是有进步的，即使忙碌的、焦躁的，绝望的日夜占了学期的大多数。要说这学期最喜欢最新奇收获最大的课，我觉得应该是当仁不让的15-122。<br><a id="more"></a> </p><p>迫于淫威，选择了这门不计入毕业学分的本科生level的CS课，全名叫做Principles of Imperative Programming，以教授命令式编程（C）与基本的数据结构为主线，是要declare CS major的学生必修的基础课以及核心课程。所以有200+的学生和30+的TA，并且基本上所有的学生都是first year（first year graduate的我惭愧的低下了头）。</p><p>这门课的workload要比我这学期上的所有其他研究生课程的workload都来的大。每周一交一个written homework（共13次），每周四交一个programming homework（共11次），每周两次lecture，课上会有随机的quiz（计入总分），每周一次lab（计入总分），每周一次recitation，两次midterm和一次final。</p><p>这门课讲了什么呢？首先从最最基础的二进制讲起，然后开始将数据结构与零零散散的东西穿插起来介绍（看到syllabus可以感觉到每节lecture的内容都是精心安排的）。数据结构有介绍了array，stack，queue，linked list，unbounded array，hash tables，set，BST，AVL tree，priority queue，heap，graph，union find等。</p><p>但是这门课不光只是介绍了数据结构，还有很多零零碎碎的东西也被提上了桌面。比如说lecture里有教几种sort和search的方法，命令式编程中的pointer和function pointer，编程时需要尊重client和library的interface，如何写各种test case，使用void*和函数指针写出generic的函数，C的内存模型，undefined behavior，虚拟机等。lab里有着重锻炼书写test case，recitation里还有对lecture内容的补充（比如说用stack实现DFS，课上用的是recursion）。</p><p>我为什么喜欢并推荐这门课呢？</p><p>这门课有两位负责任的instructor。Stephanie虽然上课十句话里有一句讲错，写代码三行里必出错别字，但是上课非常有趣。在实现数据结构的interface的时候，她常常尝试用不同的方法，即使方向是完全错误的，她至少让我们看到了这么实现的弊端在哪里。作为一门CS的基础课，能够做到授之以渔便是最大的成功。Illiano作为这门课的主管，对整个课的质量把控的非常严格，所有的作业基本都是两天内出分，grading能够做到你心服口服。上课的方式也很有趣（貌似本科生的课都很有趣），比如说有一次编程作业是图片变换，有一个bonus的题，想出你最喜欢最美丽的图片变换并写代码。一周后的课堂上突如其来的评选出了top 10送小礼品+送加分。</p><p>这门课的TA非常负责（只能说有一些TA非常负责）。有一次written homework我做的比较差，因为有一道大题没太明白题目意思，于是就去OH准备和TA把分数argue回来，她非常耐心的和我解释每一条扣分点在哪里，把本来打算找他们算账的我说的心服口服。更加负责的是，后来我登录上去我的gradescope，发现她在我在OH问的那些问题的旁边把她的解释完整的加在了备注里，为的是我考试复习的时候比较方便。这是最最最让我感动的一点。还有，midterm2的时候，我因为时间来不及胡乱猜了两三个答案写在试卷上，有两个蒙对了但是TA没给我分。跑过去regrade，ta说一看你就是不会写瞎蒙的，不能给你分。</p><p>课程的设置非常的有foresight。学期初有一次编程作业里的一个task是对图片做高斯模糊，其中的一个步骤是对图片加padding，并且用方格遍历选取最大的元素。后来上到601 CNN的时候，才明白过来原来这就是CNN里的max pooling layer。其他的作业也非常实用，比如说用gap buffer实现text editor，写一个PRNG，使用heap实现huffman tree然后变成一个用来压缩文件的程序（真的可以用来压缩和解压缩文件和图片！），写一个虚拟机的decoder，类似于汇编码的decoder（真的可以用来跑c0文件的bytecode！）。</p><p>很难，很push。push是我对这门课最大的感受。比如说好死好活写了一次programming homework，只占总分里的2.5分，一次written homework只占100分的的1.2分。并且这门课是不curve的，严格按照90分以上是A的标准。真是对于任何一次作业都不敢不好好做（否则一次扣0.5分真的伤不起）。同时，总评的grading还会case by case，意思就是即使总评90+，如果三次考试的平均分不到80%，也会按照B处理。或者是如果programming homework的分数太低，就会收到D的总评，直接剥夺下学期选15-213的权利。这门课的push同时还体现在每次作业限制autolab的提交次数（5-7次），以及coding style的规范，以及有几次的作业需要考虑efficiency，以及有几次的作业是在due之后才会给你评分（意味着无法根据autolab的提示进行debug）。</p><p>整个课程的材料都让我感觉到设置的精心。比如说基本上每次的编程作业，都会提供几百个test case来测试你程序是否有bug。像最后一次作业，他写了350+个的test case来测试你的程序，我觉得这在一般的课程上是做不到的吧。另外，为了上这门课，这门课当初的设计者写了一门新的语言叫做C0。C0是C语言的一个子集，里面剥夺了一些容易让程序失控的特性，比如说casting，比如动态内存的回收，比如指针运算，比如一些ECF（break等）。同时添加了新的数据类型比如string，以及string的操作（以替代神烦的strxxx系列）。为了一门课程直接写一门新语言真的是细想极恐。</p><p>总而言之，15122真的是我到目前为止最满意的CS课（甚至超过15-513），强烈推荐闲的发慌的人去上一波。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安然无恙（其实头发很有恙）的度过了在匹兹堡的第一个学期，能在五门课中活下来证明还是有进步的，即使忙碌的、焦躁的，绝望的日夜占了学期的大多数。要说这学期最喜欢最新奇收获最大的课，我觉得应该是当仁不让的15-122。&lt;br&gt;
    
    </summary>
    
      <category term="Geek" scheme="http://yoursite.com/categories/Geek/"/>
    
    
      <category term="Course" scheme="http://yoursite.com/tags/Course/"/>
    
  </entry>
  
</feed>
